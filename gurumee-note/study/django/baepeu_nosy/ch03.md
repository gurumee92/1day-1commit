튜토리얼 따라하기 - 설문 조사 서비스 만들기
=====================

> 책 "베프의 오지랖 파이썬 웹 프로그래밍" 정리한 문서입니다. 책은 저자들의 소중한 자산이기 때문에 책에 나와 있는 모든 내용을 기술하지 않고 최대한 압축해서 정리할 예정입니다. 이 책을 정리하는 이유는 "11번가 하계 인턴" 동안 수행해야 하는 개인 과제 "통합 검색 서비스"를 만들기 위해서 연구 목적입니다.

Contents
-------------

이번 장에서 배울 목차는 다음과 같습니다.

1. 시작하며..
2. 설문 조사 앱 만들기
    1. 설문 조사 앱 만들기
    2. 첫 번째 뷰 만들기
    3. 모델 만들기
    4. 관리자 만들기
    5. 여러가지 뷰 추가하기
    6. 정적 파일 사용하기
    7. 관리자 페이지 커스터마이징
3. 마치며..

## 시작하며..

이번 장에서는 지난 시간에 만든 튜토리얼 프로젝트를 계속해서 진행할 예정입니다. 다소 내용이 많을 수 있으니 마음을 단단히 붙잡고 시작해 봅시다.

## 설문 조사 앱 만들기

자 호흡 한 번 쉬고, 바로 달려봅시다!

### 설문 조사 앱 만들기

먼저 장고에서는 기능 단위를 앱으로 구분합니다. 프로젝트에서 다음을 입력하세요.

```bash
$ (venv) python manage.py startapp polls
```

    참고! 
    가상환경이 켜져있는지 꼭 확인해주세요!

그러면, polls 디렉토리가 생성되고 다음의 하위 폴더가 만들어질 겁니다.

- polls
    - __init__.py
    - admin.py
    - apps.py
    - models.py
    - tests.py
    - views.py

### 첫 번째 뷰 만들기

이제 `polls/views.py`에 다음을 입력해주세요.

project/polls/views.py
```python
from django.http import HttpResponse
# Create your views here.
def index(request):
    return HttpResponse("Hello world, You're at the polls index")
```

그 후 이 뷰를 url과 연결시켜야 합니다. `polls/urls.py`를 만들고 다음을 입력해주세요.

project/polls/urls.py
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='polls/index')
]
```

`path(route, view, kwargs, name)`
- route 해당 주소를 의미합니다. '' 라면 '/'과 같습니다.
- view 해당 주소의 연결된 뷰입니다. 함수 혹은 클래스.as_view() 형태입니다.
- kwargs 뷰에 전달할 값들입니다.
- name route의 이름을 뜻합니다.  

이제 프로젝트에서 이 앱의 url을 연결시켜주어야 합니다. `config/urls.py`를 다음과 같이 수정해주세요.

project/config/urls.py
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('polls/', include('polls.urls')),
]
```

include 함수는 다른 앱의 urls.py를 참조할 수 있는 헬퍼 메소드입니다. 이제 `localhost:8000/polls/`로 접속하면 우리가 만든 index 뷰가 보일겁니다.

### 모델 만들기

먼저 모델을 만들기 전에 `config/settings.py`에 DATABASE 라는 값을 찾아봅시다. 

project/config/setting.py
```python
# ...

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

# ...
```

이것은 sqlite3 엔진은 쓰겠다는 의미입니다. 장고 프레임워크는 기본적으로 sqlite3, mysql, postgresql, oracle을 지원하며 서드파티로 다양한 데이터베이스를 손쉽게 설정할 수 있습니다. 이제 데이터베이스를 만들고 초기화하기 위해서 다음의 명령어를 입력합시다.

```bash
$ (venv) python manage.py migrate
```

그 후, `polls/models.py`를 다음처럼 수정해 주세요.

project/polls/models.py
```python

from django.db import models

# Create your models here.
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

    def __str__(self):
        return self.question_text

    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)



class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text
```

장고의 모델은 `models.Model`을 상속받아 만듭니다. 이 클래스가 ORM을 이용하여 데이터베이스를 손쉽게 만들어줍니다. 여기서 특이한 점은 `Choice`의 `ForeignKey` 부분입니다. 이는 `Question`과 관계를 가지며 Question은 Choice를 여러 개를 가질 수 있음을 뜻합니다. 또한 기본적으로 클래스이기 때문에 메소드를 만들고 상속받을 수 있습니다.

이제 프로젝트와 앱을 연결해줍시다. `config/settings.py`를 열고 **INSTALLED_APPS** 를 다음처럼 수정해주세요.

project/config/settings.py
```python
# ..

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'polls', # 'polls.apps.PollsConfig'
]

# ..
```

이렇게 하면 프로젝트와 polls 앱이 직접적으로 연결됩니다. 이제 모델을 DB에 적용시켜야 합니다. 다음 명령어를 입력해주세요.

```bash
$ (venv) python manage.py makemigrations polls
```

### 관리자 만들기

장고의 가장 큰 이점 중 하나는 관리자 페이지를 손쉽게 생성할 수 있다는 것입니다. 먼저 관리자를 만들어 보도록 하겠습니다.

```bash
$ (venv) python manage.py createsuperuser
```

이러면 ID와 이메일, 비밀번호를 입력하라고 터미널에서 요구합니다. 적당히 쳐주시면 됩니다. 이제 웹 서버를 키시면 `localhost:8000/admin`으로 접속하면 로그인 창이 뜨고 로그인하면 관리할 수 있는 페이지가 나옵니다. 이제 이 페이지에 `Question`을 관리할 수 있도록 만들어보겠습니다. `polls/admin.py`를 열고 다음처럼 수정하세요.

project/polls/admin.py
```python

from django.contrib import admin

from .models import Question
# Register your models here.

admin.site.register(Question)
```

보통 앱의 admin.py는 앱의 모델들을 관리자 페이지로 연동시키는 파일입니다. 위와 같이 `Question` 등의 모델을 연결시켜줄 수 있습니다. 다시 관리자 페이지를 접속해보면 `Question`이 뜬 것을 확인할 수 있습니다. 여기서 데이터 몇 개를 입력해두세요! 

### 여러가지 뷰 추가하기

자 이제 다음의 뷰를 만들어볼 차례입니다.

1. 투표 목록 
2. 투표 상세 보기
3. 투표 기능 
4. 투표 결과

장고 프레임워크에서 뷰는 함수 혹은 `generic` 밑에 있는 뷰 클래스로 만들 수 있습니다. `polls/views.py`를 다음처럼 수정해주세요.

project/polls/views.py
```python
from django.shortcuts import render, get_object_or_404
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.views import generic

from .models import Question, Choice

# Create your views here.

class IndexView(generic.ListView):
    template_name='polls/index.html'
    context_object_name='latest_question_list'

    def get_queryset(self):
        """Return the last five published questions"""
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'

def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)

    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        return render(request, 'polls/detail.html', {
            "question": question,
            "error_message": "You didn't select a choice."
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()

        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
```

vote 는 뷰 함수이며 나머지는 generic 뷰를 상속시킨 클래스들입니다. 이제 urls.py를 수정해주세요.

project/polls/urls.py
```python
from django.urls import path
from . import views

app_name = 'polls'

urlpatterns = [
    # /polls/
    path('', views.IndexView.as_view(), name='index'),
    # /polls/5
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    # /polls/5/results
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    # /polls/5/vote
    path('<int:question_id>/vote/', views.vote, name='vote'),
]
```

    참고! <int:pk>? <int:question_id>?
    이것들은 url path로 정해진 값 들입니다. 함수 뷰의 경우 우리가 이름을 지정해서 쓸 수 있지만, 제네릭 뷰의 경우는 pk 로 그 값을 지정해야 합니다.

이제 클라이언트에게 보일 페이지들, 템플릿을 작성해봅시다. polls 에 `templates`를 만들고 다시 polls를 만듭니다. 그 후 index.html, detail.html, results.html 을 만들어줍니다.

project/polls/templates/polls/index.html
```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Django Tutorial</title>
    </head>
    <body>
        {% if latest_question_list %}
        {% else %}
        <p>No polls are available</p>
        {% endif %}
    </body>
</html>
```

project/polls/templates/polls/detail.html
```
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Django Tutorial</title>
    </head>
    <body>
        <h1>{{ question.question_text }}</h1>

        {% if error_message %}
            <p><strong>{{ error_message  }}</strong></p>
        {% endif %}

        <form action="{% url 'polls:vote' question.id %}" method="post">
            {% csrf_token %}
            {% for choice in question.choice_set.all %}
                <input type="radio" name="choice" id="choice{{ forloop.couter }}" value="{{choice.id}}" />
                <label for="choice{{ forloop.couter }}">{{ choice.choice_text }}</label> <br/>
            {% endfor %}
            <input type="submit" value="Vote">
        </form>
    </body>
</html>
```

project/polls/templates/polls/results.html
```html
  
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Django Tutorial</title>
    </head>
    <body>
        <h1>{{ question.question_text }}</h1>
        <ul>
            {% for choice in question.choice_set.all %}
                <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
            {% endfor %}
        </ul>

        <a href="{% url 'polls:detail' question.id%}">Vote Again?</a>
    </body>
</html>
```

자 여기서는 간단한 폼 설정 및 url namespace 적용, 하드 코딩된 url 제거하기 등의 여러 장고의 편리한 기능들을 사용하였습니다. 이는 책에서 참고할 수 있습니다. 이제 애플리케이션을 구동해보면, 페이지가 잘 이동하는 것을 확인할 수 있습니다.

### 정적 파일 사용하기

자 페이지를 간단하게 꾸며봅시다. 그럴려면 css 파일이 있어야겠죠? `polls/static/polls/style.css` 를 해당 경로에 맞게 잘 만들어주세요.

project/polls/static/polls/style.css
```css
body {
    background: black;
}

li a {
    color: blue;
}
```

이제 index.html 에만 적용해보겠습니다. `polls/tetmplates/polls/index.html` 을 다음처럼 수정해주세요.

project/polls/templates/polls/index.html
```html

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Django Tutorial</title>
        {% load static %}
        <link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}"/>
    </head>
    <!-- 이전 코드와 동일합니다. -->
</html>
```

이제 `localhost:8000/polls`로 가면, 스타일이 적용된 것을 볼 수 있습니다.

### 관리자 페이지 커스터마이징

이제 관리자 페이지를 조금만 수정해보도록 합시다. 자 `polls/admin.py`를 다음처럼 수정해주세요.

project/polls/admin.py
```python
from django.contrib import admin

from .models import Question, Choice
# Register your models here.

class ChoiceInline(admin.TabularInline):
    model = Choice
    extra = 3

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, { 'fields': ['question_text'] }),
        ('Date Information', { 'fields': ['pub_date'] })
    ]

    list_display = ('question_text', 'pub_date', 'was_published_recently')

    inlines = [ChoiceInline]

    list_filter = ['pub_date']
    search_fields = ['question_text']

admin.site.register(Question, QuestionAdmin)
```

먼저 `Choice`를 `Question` 내에서 수정할 수 있도록 `ChoiceInline`을 만들었습니다. 이제 해당 필드셋들과 보여주어야할 필드, 그리고 필터링할 수 있는 필드와, 검색 필드들을 지정해주었습니다. 이렇게 하기 위해서는 모델 작업도 더러 필요합니다. `polls/models.py`를 수정해주세요.

project/polls/models.py
```python
from django.db import models
from django.utils import timezone
import datetime

# Create your models here.
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

    def __str__(self):
        return self.question_text

    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
    
    was_published_recently.admin_order_field = 'pub_date'
    was_published_recently.boolean = True
    was_published_recently.short_description = 'published recently'
    


class Choice(models.Model):
    # 이전과 동일
```

메소드 `was_published_recently`를 admin.py 에서 사용할 수 있도록 설정한 것입니다. 이제 서버를 키고 관리자 페이지를 들어가보면 이전보다 훨씬 좋아진 Question 관리 페이지를 만날 수 있을겁니다.


## 마치며..

이로써 장고 튜토리얼을 마쳤습니다. 해당 튜토리얼은 장고 공식 사이트에서도 제공하고 있습니다. 다음 URL을 참고해주세요.

* [장고 튜토리얼](https://docs.djangoproject.com/ko/2.2/intro/)

다음 시간에는 `북마크` 라는 웹 애플리케이션을 만들면서 보다 장고에 대한 기능을 알아보도록 하겠습니다.