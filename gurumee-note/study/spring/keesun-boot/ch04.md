스프링 부트 활용 1부 Spring Boot 핵심 기능
============================

> 인프런 강좌 "백기선의 스프링 부트"와 책 "스프링 철저 입문"을 보고 스프링 부트에 대해 정리한 내용입니다. 

Contents
---------------

1. 시작하며..
2. SpringApplication
3. 외부 설정
4. 프로파일
5. 로깅
6. 테스트
7. Spring-Boot-Devtools
8. 마치며..


## 시작하며..

이번 장에서는 스프링 부트를 활용하는데 있어 꼭 필요한 핵심 기능들을 살펴 봅니다. 간단하게 살펴보면 다음과 같습니다.

* SpringApplication
* 외부 설정
* 프로파일
* 로깅
* 테스트
* Spring-Boot-Devtools

자 시작해봅시다.


## SpringApplication

먼저 `SpringApplication` 커스터마이징 할 수 있는 방법을 보겠습니다. 커스터마이징을 위해서 main 코드를 다음과 같이 변경해주세요.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
		application.run(args);
	}
}
```

원래는 `SpringApplication`의 스태틱 메소드 run()을 사용하였는데, 이 코드는 `SpringApplication` 인스턴스를 직접 생성하는 부분입니다. 이렇게 하면 추가적으로 커스터마이징을 더 할 수 있는 부분이 생깁니다. 먼저, 배너를 바꿔볼까요?

먼저 resources 디렉토리에 banner.txt를 만들고 다음을 입력해주세요.

src/main/resource/banner.txt
```
=========================================================
    Gurumee's Spring Boot ${spring-boot.version} ${application.version}
=========================================================
```

이렇게 하고 애플리케이션을 실행해보겠습니다. 이 경우, ${spring-boot.version}의 값은 뜨지만 ${application.version}의 값은 뜨지 않습니다. 안뜨는 프로퍼티는 매니페스트 파일이 필요한데요. 터미널에서 메이븐 패키징 후에 프로젝트를 실행시켜보세요. 스프링 부트의 "실행 가능한 JAR" 만드는 기능 때문에, 매네페스트 파일이 만들어져, ${application.version}의 값도 뜨게 됩니다.

배너로 설정할 수 있는 파일은 txt, img, gif 등이 있으며, `SpringApplication` 인스턴스를 통해서 코드 레벨에서 작성할 수 있습니다. 한 번 작성해볼까요?

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
        application.setBanner(new Banner() {
            @Override
            public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
                out.println("========================");
                out.println("HELLO SPRING!");
                out.println("========================");
            }
        });
		application.run(args);
	}
}
```

자, 지금 `banner.txt`와 코드로 배너를 작성했습니다. 어느 것을 따를까요? 정답은 놀랍게도 text파일이 이깁니다. 아무래도 배너에 관해서는 정적 리소스 파일이 우선권을 가지나 봅니다.

이번에는 `ApplicationEvent`를 살펴보겠습니다. 스프링 프레임워크에서 제공하는 이벤트들과, 스프링 부트에서 제공하는 이벤트들에 대해서 리스너를 작성하면, 각 이벤트 발생 시, 코드를 처리할 수 있습니다. 개인적인 생각으론 리액트나 뷰의 **라이프 사이클 메소드**와 유사한 것 같습니다.

`ApplicationEvent`에 해당하는 이벤트 리스너를 만드는데, 어떤 것은 빈으로 등록하면, 자동으로 이벤트가 발생되면, 리스너가 처리하고, 어떤 것은 빈으로 등록되도 리스너가 동작하지 않는데요, 이는 이벤트들과 `ApplicationContext`의 생성 기점과 관계가 깊습니다.
 
 만약 `ApplicationContext` 생성 이전에 발생하는 이벤트라면, 해당 이벤트의 리스너를 빈으로 등록하더라도 동작하지 않습니다. 반면 생성 이후에 발생하는 이벤트라면, 빈으로 등록만 하더라도 리스너가 동작합니다. 간단한 예를 들어볼까요?


app/src/main/java/com/gurumee/app/ApplicationStartingEventListener.java
```java
package com.gurumee.app;

import org.springframework.boot.context.event.ApplicationStartingEvent;
import org.springframework.context.ApplicationListener;

public class ApplicationStartingEventListener implements ApplicationListener<ApplicationStartingEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {
        System.out.println("===========================");
        System.out.println("Application Starting EVENT!");
        System.out.println("===========================");
    }
}
```

이 리스너 클래스의 경우, 빈으로 등록하더라도 리스너는 동작하지 않습니다. 바로 `ApplicationStartingEvent`가 `ApplicationContext` 생성 이전에 발생하는 이벤트이기 때문입니다. 이 경우 어떻게 리스너를 동작시킬 수 있을까요? 바로 `SpringApplication` 인스턴스의, `addListener` 메소드를 통해서 리스너를 등록할 수 있습니다.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
        //ApplicationStartingEventListener 등록
        application.addListeners(new ApplicationStartingEventListener()); 

		application.run(args);
	}
}
```

이번엔 `ApplicationContext` 생성 이후에 발생하는 이벤트 리스너를 만들어보겠습니다.

app/src/main/java/com/gurumee/app/ApplicationStartedEventListener.java
```java
package com.gurumee.app;

import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class ApplicationStartedEventListener implements ApplicationListener<ApplicationStartedEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartedEvent applicationStartedEvent) {
        System.out.println("===========================");
        System.out.println("> Application Started EVENT! <");
        System.out.println("===========================");
    }
}
```

`ApplicationStartedEvent`은 `ApplicationContext` 생성 이후에 발생하는 이벤트입니다. @Component 애노테이션을 통해 빈으로 만들었는데, 애플리케이션을 실행시켜보세요. `ApplicationStartingEventListener`와 달리 등록 코드를 작성하지 않았음에도, 리스너가 동작하는 것을 확인 할 수 있습니다.

이번에는 `WebApplicationType`을 설정하는 부분을 살펴보겠습니다. 기본적으로 `WebApplicationType`는 다음의 값이 있습니다.

* SERVELET
* REACTIVE
* NONE

`SERVELET`은 서블릿 기반의 스프링 웹 애플리케이션, `REACTIVE`는 웹 플럭스 기반의 스프링 웹 애플리케이션, `NONE`은 스프링 애플리케이션 타입입니다. 기본적으로 타입은 모든 의존성이 들어가 있다고 했을 때 다음의 우선순위를 가집니다.

    서블릿(SERVLET) > 웹 플럭스(REACTIVE) > NONE

이들을 명시적으로 타입을 선언할 수 있는데, 역시 `SpringApplication` 인스턴스 메소드 `setWebApplicationType` 메소드로 지정해줄 수 있습니다.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
        application.addListeners(new ApplicationStartingEventListener()); 
        // 그냥 스프링 애플리케이션 타입으로 애플리케이션 생성
        application.setWebApplicationType(WebApplicationType.NONE);
		application.run(args);
	}
}
```

이번에는 프로그램 옵션을 활용할 수 있는 `ApplicationArguments`를 살펴보겠습니다. 먼저 자바 옵션은 다음으로 나눠집니다.

    -D JVM option
    -- 프로그램 아규먼트

특정 빈에서 프로그램 아규먼트를 이용하기 위해서 빈의 생성자에 `ApplicationArguments`를 파라미터로 넘겨주면 됩니다. 

app/src/main/java/com/gurumee/app/ApplicationArgumentPrinter.java
```java
package com.gurumee.app;

import org.springframework.boot.ApplicationArguments;
import org.springframework.stereotype.Component;

@Component
public class ApplicationArgumentPrinter {

    public ApplicationArgumentPrinter(ApplicationArguments args) {
        System.out.println("foo: " + args.containsOption("foo"));
        System.out.println("bar: " + args.containsOption("bar"));
    }
}
```

이 빈은 생성시에, 프로그램 아규먼트에 `foo`,와 `bar`가 있는지 출력합니다. 터미널에 다음을 입력하세요.

```bash
# maven package
$ mvn clean package

# move app/target
$ cd app/target

# execute
$ java -jar app-0.0.1-SNAPSHOT.jar -Dfoo --bar
```

위 명령어는 JVM 옵션으로 `foo`를 프로그램 옵션으로 `bar`를 넘겨준 것입니다. 이러면 터미널 출력 문구에 다음이 뜰 것입니다.

```
foo: false
bar: true
```

이렇게 프로그램 옵션을 사용할 수 있습니다.

또한, 이제 `SpringRunner`들이 있는데, 애플리케이션 실행 후에 다른 실행 흐름들을 만들어줄 수 있습니다. 크게 2가지가 있는데요. 다음과 같습니다.

* ApplicationRunner 
* CommandLinRunner

`ApplicationRunner`가 추천 사항입니다. 왜냐하면, 어차피 둘 다 JVM 옵션을 쓸 수 없고 프로그램 옵션만 받는데 `ApplicationRunner`는 고도로 추상화된 `ApplicationArguments`를 쓸 수 있고 `CommandLinRunner` 단순 `String` 배열을 받을 뿐 `ApplicationArguments`를 쓸 수 없습니다. 그러니까 어지간하면 `ApplicationRunner` 쓰는게 좋습니다. 

또한, @Order 를 통해 러너들의 실행 순서를 정해줄 수 있습니다. 참고적으로 @Order 에 넘겨준 숫자가 낮은게 우선 순위가 높습니다.

`SpringApplication` 커스터마이징 하는 방법은 인스턴스 생성 외에`SpringApplicationBuilder`로 `SpringApplication` 만드는 방법이 있습니다. 결국 인스턴스 생성은 같은데, 애플리케이션 설정을 빌더 패턴으로 짤 수 있습니다. 이렇게 말이죠.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
        new SpringApplicationBuilder()
				.sources(DemoApplication.class)
				.run(args);
	}
}
```


## 외부 설정

이번에는 스프링 부트 핵심 기능 중 하나인 `외부 설정`을 살펴보겠습니다. 일반적으로 외부 설정은 `application.properties` 혹은 `application.yml`에 키-값 쌍으로 값을 지정합니다. 그리고 스프링 부트에서는 이 `외부 설정`에 대한 값들을 간단하게 가져다 쓸 수 있습니다. 먼저 `application.properties`에 다음을 입력해주세요.

app/src/main/resources/application.properties
```
gurumee.name=gurmee
gurumee.age=${random.int(0,100)}
```

이제 이 값들을 받아와서 출력하는 러너를 만들겠습니다. `GurumeeRunner`를 만들고 다음을 작성해주세요.

app/src/main/java/com/gurumee/app/GurumeeRunner.java
```java
package com.gurumee.app;

// import

@Component
public class GurumeeRunner implements ApplicationRunner {

    @Value("${gurumee.name}")
    String name;

    @Value("${gurumee.age}")
    int age;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("gurumee runner: " + name + " age: " + age);
    }
}
```

`@Value` 애노테이션에 `SpEL`을 써서 `application.properties`에 저장된 프로퍼티들을 불러왔습니다. 그리고 이를 출력하지요. 애플리케이션을 돌려보면, 이름과, 나이에 대해서 출력문을 볼 수 있을겁니다.

근데 이렇게 하면, 데이터를 불러오는데 있어서 타입세이프하지 않습니다. 조금 더 타입세이프한 방법을 쓰도록 하겠습니다. 바로 `Properties` 클래스를 만드는건데요. `GurumeeProperties`를 다음과 같이 만들어 주세요.

app/src/main/java/com/gurumee/app/GurumeeProperties.java
```java
package com.gurumee.app;

// import

@Component
@ConfigurationProperties("gurumee")
public class GurumeeProperties {

    String name;
    int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

`@ConfigurationProperties`에 전체적인 키의 값을 주면 프로퍼티 클래스로 만들어서 값을 받아올 수 있습니다. 무슨 말이냐면, gurumee.name, gurumee.age 모두 "gurumee"로 시작합니다. 즉 gurumee로 값을 지정하면 그 밑에 하위 키들에 대한 값들을 받아올 수 있는 것이죠. 그리고 무엇보다, 빈으로 등록을 해둬야 이 프로퍼티 클래스를 쓸 수 있습니다. 이제 `GurumeeRunner`를 다음처럼 수정해주세요.

app/src/main/java/com/gurumee/app/GurumeeRunner.java
```java
package com.gurumee.app;

// import

@Component
public class GurumeeRunner implements ApplicationRunner {

    @Autowired
    private GurumeeProperties properties;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("gurumee runner: " + properties.getName() + " age: " + properties.getAge());
    }
}
```

역시 애플리케이션을 실행해도 같은 결과를 얻을 수 있습니다. **참고적으로 `Properties` 클래스들은 `JSR-330`을 통해서 데이터에 대한 유효성 검사도 할 수 있습니다.**

조금 더 살펴보자면, 프로퍼티를 주는데도 우선 순위가 있습니다. 그 우선순위는 다음과 같습니다.

    (test 시에는 아래 3개가 우선수위를 갖습니다.)
    * @TestPropertySource 붙은 프로퍼티 파일
    * @SpringBootTest(properties = "")
    * test/resources/application.properties 

    * program arguments  
    * 환경 변수 SPRING_APPLICATION_JSON
    * 시스템 프로퍼티
    * OS 환경변수
    * application.properties
    * 스프링 기본 프로퍼티

1가지만 살펴볼까요? `test` 디렉토리에 `resources`를 만들고 테스트-리소스 설정을 해주세요. 그 후, application.properties를 만들고 다음을 입력해주세요.

app/test/main/resources/application.properties
```
gurumee.name=test
```

이렇게 하고 테스트 코드를 돌려볼까요? 그럼 어떤 값이 출력이 될까요? 정답은 테스트 리소스 파일에 들어있는 값 "test"가 출력이 됩니다. 왜냐하면, 빌드 시에, main 소스 코드를 모두 빌드한 후, test 소스 코드를 빌드해서 같은 것이 있으면 덮어 써버리기 때문입니다.

한 가지만 더 알아보겠습니다. 외부 설정 파일 *.properties 들은, 기본적으로 4곳에다가 저장할 수 있습니다. 그리고 저장 장소에 따라서 우선순위가 있어 같은 것이 있으면, 역시 우선순위에 따라 설정 파일을 덮어 씁니다. 우선 순위는 다음과 같습니다.

1. file:../config/
2. file:../
3. classpath:/config/
4. classpath:/

꽤 빈번하게 쓰이는 기능이나 이 정도만 알아도 쓰는데는 문제 없을 것입니다. 자세한 사항은 스프링 공식 문서를 참조하세요.


## 프로파일

프로파일은 운영 환경에 따라서 애플리케이션 설정을 바꾸는데 쓰는 기능입니다. 먼저 Configuration 파일들을 만들겠습니다.

app/src/main/java/com/gurumee/app/config/ProdConfiguration.java
```java
package com.gurumee.app.config;

//import

@Profile("prod")
@Configuration
public class ProdConfiguration {
    @Bean
    public String hello() {
        return "prod";
    }
}
```

app/src/main/java/com/gurumee/app/config/TestConfiguration.java
```java
package com.gurumee.app.config;

// import

@Profile("test")
@Configuration
public class TestConfiguration {
    @Bean
    public String hello() {
        return "test";
    }
}
```

각각 "prod", "test" 운영 환경 시, 다른 설정을 주기 위해서 이러한 코드를 사용합니다. 이 때 두 설정 모두 `hello` 빈이 등록되는데, 운영환경이 prod 때는 "prod", test 때는 "test"라는 문자열 빈을 등록합니다. 이제 이 빈을 쓰는 러너를 만들지요.

app/src/main/java/com/gurumee/app/runner/ProfileRunner.java
```java
package com.gurumee.app.runner;

// import

@Component
public class ProfileRunner implements ApplicationRunner {

    @Autowired
    private String hello;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("=============================");
        System.out.println(hello);
        System.out.println("=============================");
    }
}
```

자 이제, 애플리케이션을 실행해보죠. 실행해보면, 에러가 뜹니다. 왜냐하면, 2개의 프로파일이 있는데, 어느것을 쓸지 명시하지 않았기 때문입니다. `application.properties`에 다음을 입력해주세요.

app/src/main/resources/application.properties
```
spring.profiles.active=prod
```

자 이제 실행해보면 prod 문자열이 출력하는 것을 확인할 수 있습니다. 이제 설정한 값에 test를 설정해보세요. test 문자열이 출력될겁니다. 그리고 프로젝트 패키징 시, 프로파일을 줄 수 있습니다. 이 때 기본적으로 `application.properties`를 참고합니다.

이 때, 만약 프로파일이 prod, 그리고 외부 설정 파일로 `applciation-prod.properties`가 존재한다면, 이 파일의 설정을 따르게 됩니다. 그리고 `applciation-prod.properties`는 `application.properties` 값들을 오버라이딩하게 됩니다. 

    참고! spring.profiles.include
    만약 외부 설정 파일에 다른 설정 파일의 설정을 쓰고 싶다면 설정 파일에 spring.profiles.include의 값을 주면 됩니다. 만약, application-prod 에서 application-proddb 설정을 포함하고 싶다면, spring.profiles.include=proddb 이렇게 쓰면 됩니다.


## 로깅


## 테스트


## Spring-Boot-Devtools


## 마치며..

