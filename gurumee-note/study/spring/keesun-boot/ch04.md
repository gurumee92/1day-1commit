스프링 부트 활용 1부 Spring Boot 핵심 기능
============================

> 인프런 강좌 "백기선의 스프링 부트"와 책 "스프링 철저 입문"을 보고 스프링 부트에 대해 정리한 내용입니다. 

Contents
---------------

1. 시작하며..
2. SpringApplication
3. 외부 설정
4. 프로파일
5. 로깅
6. 테스트
7. Spring-Boot-Devtools
8. 마치며..


## 시작하며..

이번 장에서는 스프링 부트를 활용하는데 있어 꼭 필요한 핵심 기능들을 살펴 봅니다. 간단하게 살펴보면 다음과 같습니다.

* SpringApplication
* 외부 설정
* 프로파일
* 로깅
* 테스트
* Spring-Boot-Devtools

자 시작해봅시다.


## SpringApplication

먼저 `SpringApplication` 커스터마이징 할 수 있는 방법을 보겠습니다. 커스터마이징을 위해서 main 코드를 다음과 같이 변경해주세요.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
		application.run(args);
	}
}
```

원래는 `SpringApplication`의 스태틱 메소드 run()을 사용하였는데, 이 코드는 `SpringApplication` 인스턴스를 직접 생성하는 부분입니다. 이렇게 하면 추가적으로 커스터마이징을 더 할 수 있는 부분이 생깁니다. 먼저, 배너를 바꿔볼까요?

먼저 resources 디렉토리에 banner.txt를 만들고 다음을 입력해주세요.

src/main/resource/banner.txt
```
=========================================================
    Gurumee's Spring Boot ${spring-boot.version} ${application.version}
=========================================================
```

이렇게 하고 애플리케이션을 실행해보겠습니다. 이 경우, ${spring-boot.version}의 값은 뜨지만 ${application.version}의 값은 뜨지 않습니다. 안뜨는 프로퍼티는 매니페스트 파일이 필요한데요. 터미널에서 메이븐 패키징 후에 프로젝트를 실행시켜보세요. 스프링 부트의 "실행 가능한 JAR" 만드는 기능 때문에, 매네페스트 파일이 만들어져, ${application.version}의 값도 뜨게 됩니다.

배너로 설정할 수 있는 파일은 txt, img, gif 등이 있으며, `SpringApplication` 인스턴스를 통해서 코드 레벨에서 작성할 수 있습니다. 한 번 작성해볼까요?

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
        application.setBanner(new Banner() {
            @Override
            public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
                out.println("========================");
                out.println("HELLO SPRING!");
                out.println("========================");
            }
        });
		application.run(args);
	}
}
```

자, 지금 `banner.txt`와 코드로 배너를 작성했습니다. 어느 것을 따를까요? 정답은 놀랍게도 text파일이 이깁니다. 아무래도 배너에 관해서는 정적 리소스 파일이 우선권을 가지나 봅니다.

이번에는 `ApplicationEvent`를 살펴보겠습니다. 스프링 프레임워크에서 제공하는 이벤트들과, 스프링 부트에서 제공하는 이벤트들에 대해서 리스너를 작성하면, 각 이벤트 발생 시, 코드를 처리할 수 있습니다. 개인적인 생각으론 리액트나 뷰의 **라이프 사이클 메소드**와 유사한 것 같습니다.

`ApplicationEvent`에 해당하는 이벤트 리스너를 만드는데, 어떤 것은 빈으로 등록하면, 자동으로 이벤트가 발생되면, 리스너가 처리하고, 어떤 것은 빈으로 등록되도 리스너가 동작하지 않는데요, 이는 이벤트들과 `ApplicationContext`의 생성 기점과 관계가 깊습니다.
 
 만약 `ApplicationContext` 생성 이전에 발생하는 이벤트라면, 해당 이벤트의 리스너를 빈으로 등록하더라도 동작하지 않습니다. 반면 생성 이후에 발생하는 이벤트라면, 빈으로 등록만 하더라도 리스너가 동작합니다. 간단한 예를 들어볼까요?


app/src/main/java/com/gurumee/app/ApplicationStartingEventListener.java
```java
package com.gurumee.app;

import org.springframework.boot.context.event.ApplicationStartingEvent;
import org.springframework.context.ApplicationListener;

public class ApplicationStartingEventListener implements ApplicationListener<ApplicationStartingEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {
        System.out.println("===========================");
        System.out.println("Application Starting EVENT!");
        System.out.println("===========================");
    }
}
```

이 리스너 클래스의 경우, 빈으로 등록하더라도 리스너는 동작하지 않습니다. 바로 `ApplicationStartingEvent`가 `ApplicationContext` 생성 이전에 발생하는 이벤트이기 때문입니다. 이 경우 어떻게 리스너를 동작시킬 수 있을까요? 바로 `SpringApplication` 인스턴스의, `addListener` 메소드를 통해서 리스너를 등록할 수 있습니다.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
        //ApplicationStartingEventListener 등록
        application.addListeners(new ApplicationStartingEventListener()); 

		application.run(args);
	}
}
```

이번엔 `ApplicationContext` 생성 이후에 발생하는 이벤트 리스너를 만들어보겠습니다.

app/src/main/java/com/gurumee/app/ApplicationStartedEventListener.java
```java
package com.gurumee.app;

import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class ApplicationStartedEventListener implements ApplicationListener<ApplicationStartedEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartedEvent applicationStartedEvent) {
        System.out.println("===========================");
        System.out.println("> Application Started EVENT! <");
        System.out.println("===========================");
    }
}
```

`ApplicationStartedEvent`은 `ApplicationContext` 생성 이후에 발생하는 이벤트입니다. @Component 애노테이션을 통해 빈으로 만들었는데, 애플리케이션을 실행시켜보세요. `ApplicationStartingEventListener`와 달리 등록 코드를 작성하지 않았음에도, 리스너가 동작하는 것을 확인 할 수 있습니다.

이번에는 `WebApplicationType`을 설정하는 부분을 살펴보겠습니다. 기본적으로 `WebApplicationType`는 다음의 값이 있습니다.

* SERVELET
* REACTIVE
* NONE

`SERVELET`은 서블릿 기반의 스프링 웹 애플리케이션, `REACTIVE`는 웹 플럭스 기반의 스프링 웹 애플리케이션, `NONE`은 스프링 애플리케이션 타입입니다. 기본적으로 타입은 모든 의존성이 들어가 있다고 했을 때 다음의 우선순위를 가집니다.

    서블릿(SERVLET) > 웹 플럭스(REACTIVE) > NONE

이들을 명시적으로 타입을 선언할 수 있는데, 역시 `SpringApplication` 인스턴스 메소드 `setWebApplicationType` 메소드로 지정해줄 수 있습니다.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
		SpringApplication application = new SpringApplication(DemoApplication.class);
        application.addListeners(new ApplicationStartingEventListener()); 
        // 그냥 스프링 애플리케이션 타입으로 애플리케이션 생성
        application.setWebApplicationType(WebApplicationType.NONE);
		application.run(args);
	}
}
```

이번에는 프로그램 옵션을 활용할 수 있는 `ApplicationArguments`를 살펴보겠습니다. 먼저 자바 옵션은 다음으로 나눠집니다.

    -D JVM option
    -- 프로그램 아규먼트

특정 빈에서 프로그램 아규먼트를 이용하기 위해서 빈의 생성자에 `ApplicationArguments`를 파라미터로 넘겨주면 됩니다. 

app/src/main/java/com/gurumee/app/ApplicationArgumentPrinter.java
```java
package com.gurumee.app;

import org.springframework.boot.ApplicationArguments;
import org.springframework.stereotype.Component;

@Component
public class ApplicationArgumentPrinter {

    public ApplicationArgumentPrinter(ApplicationArguments args) {
        System.out.println("foo: " + args.containsOption("foo"));
        System.out.println("bar: " + args.containsOption("bar"));
    }
}
```

이 빈은 생성시에, 프로그램 아규먼트에 `foo`,와 `bar`가 있는지 출력합니다. 터미널에 다음을 입력하세요.

```bash
# maven package
$ mvn clean package

# move app/target
$ cd app/target

# execute
$ java -jar app-0.0.1-SNAPSHOT.jar -Dfoo --bar
```

위 명령어는 JVM 옵션으로 `foo`를 프로그램 옵션으로 `bar`를 넘겨준 것입니다. 이러면 터미널 출력 문구에 다음이 뜰 것입니다.

```
foo: false
bar: true
```

이렇게 프로그램 옵션을 사용할 수 있습니다.

또한, 이제 `SpringRunner`들이 있는데, 애플리케이션 실행 후에 다른 실행 흐름들을 만들어줄 수 있습니다. 크게 2가지가 있는데요. 다음과 같습니다.

* ApplicationRunner 
* CommandLinRunner

`ApplicationRunner`가 추천 사항입니다. 왜냐하면, 어차피 둘 다 JVM 옵션을 쓸 수 없고 프로그램 옵션만 받는데 `ApplicationRunner`는 고도로 추상화된 `ApplicationArguments`를 쓸 수 있고 `CommandLinRunner` 단순 `String` 배열을 받을 뿐 `ApplicationArguments`를 쓸 수 없습니다. 그러니까 어지간하면 `ApplicationRunner` 쓰는게 좋습니다. 

또한, @Order 를 통해 러너들의 실행 순서를 정해줄 수 있습니다. 참고적으로 @Order 에 넘겨준 숫자가 낮은게 우선 순위가 높습니다.

`SpringApplication` 커스터마이징 하는 방법은 인스턴스 생성 외에`SpringApplicationBuilder`로 `SpringApplication` 만드는 방법이 있습니다. 결국 인스턴스 생성은 같은데, 애플리케이션 설정을 빌더 패턴으로 짤 수 있습니다. 이렇게 말이죠.

app/src/main/java/com/gurumee/app/DemoApplication.java
```java
package com.gurumee.app;

//import

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args)  {
        new SpringApplicationBuilder()
				.sources(DemoApplication.class)
				.run(args);
	}
}
```


## 외부 설정


## 프로파일


## 로깅


## 테스트


## Spring-Boot-Devtools


## 마치며..

