스프링 부트 활용 2부 Spring MVC
============================

> 인프런 강좌 "백기선의 스프링 부트"와 책 "스프링 철저 입문"을 보고 스프링 부트에 대해 정리한 내용입니다. 

Contents
---------------

01. 시작하며..
02. HttpMessageConverter
03. ViewResolver
04. 정적 리소스 지원
05. 웹 JAR
06. index 페이지와 파비콘
07. Thymeleaf
08. HtmlUnit
09. ExceptionHandler
10. HATEOAS
11. CORS
12. 마치며..


## 시작하며..

이번 장에서는 스프링 부트 환경에서 MVC를 활용하는 기술들을 살펴보도록 하겠습니다. 대략적인 내용은 다음과 같습니다.

* HttpMessageConverter
* ViewResolver
* Thymeleaf
* ExceptionHandler
* HATEOAS
* CORS
* 기타

스프링 부트는 기본적으로 `WebMvcAutoConfiurer`가 자동으로 필요한 빈들, MessageConverter, ViewResolver 등을 주입하고 있습니다. 이 장에서는 그것들을 활용하는 방법들을 살펴보겠습니다. 본격적으로, 시작하기 전에 코드를 작성하겠습니다. 

먼저 `mvc`라는 모듈을 만드세요. 그 후, 다음 의존성을 추가합니다.

mvc/pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>demo</artifactId>
        <groupId>com.gurumee</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>mvc</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

이제 `com.gurumee.mvc` 패키지를 만들고 그 밑에 `MvcApplication`을 만든 후 다음 코드를 작성해주세요.

mvc/src/main/java/com/gurumee/mvc/MvcApplication.java
```java
package com.gurumee.mvc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MvcApplication {
    public static void main(String[] args) {
        SpringApplication.run(MvcApplication.class, args);
    }
}
```

그 후 테스트 코드를 작성해주세요.

mvc/src/test/java/com/gurumee/mvc/MvcApplicationTest.java
```java
package com.gurumee.mvc;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import static org.junit.Assert.*;

@RunWith(SpringRunner.class)
@SpringBootTest
public class MvcApplicationTest {

    @Test
    public void contextLoad() {

    }
}
```

이 테스트 코드가 정상적으로 실행이 되면, 제대로 설정이 된 것입니다. 여기까지 완료가 되었으면 시작해볼까요?


## HttpMessageConverter

`HttpMessageConverter`는 스프링 프레임워크에서 제공하는 인터페이스. HTTP 요청 본문을 객체로, 객체를 HTTP 응답으로 변경할 때 사용합니다. 보통 이 2가지 애노테이션을 자주 쓰게 됩니다.

* @RequestBody 파라미터 앞에
* @ResponseBody 메소드 앞에

자 코드로 한 번 살펴보겠습니다. 먼저 자바 객체를 `@ResponseBody`를 이용해 HTTP 응답을 바꿔보겠습니다. `user`패키지를 만들고 `UserController`를 다음과 같이 작성해주세요.

mvc/src/main/java/com/gurumee/mvc/user/UserController.java
```java
package com.gurumee.mvc.user;

import org.springframework.web.bind.annotation.*;

@Controller
public class UserController {

    @GetMapping("/hello")
    public @ResponseBody String hello() {
        return "hello";
    }
}
```

일단은 URL "/hello"의 GET 요청에 대해서 "hello"를 출력하는 컨트롤러를 만들었습니다. `@RestController` 애노테이션으로 코드를 다음으로 줄일 수 있습니다.

mvc/src/main/java/com/gurumee/mvc/user/UserController.java
```java
package com.gurumee.mvc.user;

import org.springframework.web.bind.annotation.*;

@RestController
public class UserController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```

즉, @RestController는 @Controller와 @ResponseBody 애노테이션을 합친 애노테이션이란 것이죠. 한 번 테스트를 해볼까요?

mvc/src/test/java/com/gurumee/mvc/user/UserControllerTest.java
```java
package com.gurumee.mvc.user;

// import

@RunWith(SpringRunner.class)
@WebMvcTest(UserController.class)
public class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        mockMvc.perform( get("/hello") )
            .andExpect( status().isOk() )
            .andExpect( content().string("hello") )
        ;
    }
}
```

자 이 테스트가 통과하는지 확인해보세요. 이 코드는 컨트롤러 계층의 슬라이싱 테스트를 진행한 코드입니다. 이번에는 URL "/user"에 POST 요청에 대해 처리하는 코드를 짜보겠습니다. POST는 사용자가 웹 서버에 요청 본문을 보내주어야 합니다. 그것을 표현하는 것이 `@RequestBody` 입니다. 이 애노테이션을 이용하면, 손쉽게 요청 본문을 자바 객체를 손쉽게 바꿔줄 수있습니다. `UserController`에 다음 코드를 추가해주세요.

mvc/src/main/java/com/gurumee/mvc/user/UserController.java
```java
package com.gurumee.mvc.user;

import org.springframework.web.bind.annotation.*;

@RestController
public class UserController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }

    //아래 코드가 추가 코드입니다.
    @PostMapping("/user")
    public User create(@RequestBody User user) {
        return user;
    }
}
```

또한, 컴파일 오류가 안나게끔 `User` 클래스를 만들도록 하죠.

mvc/src/main/java/com/gurumee/mvc/user/User.java
```java
package com.gurumee.mvc.user;

public class User {

    private Long id;

    private String username;

    private String password;

    public User() {

    }

    public User(Long id, String username, String password){
        this.id = id;
        this.username = username;
        this.password = password;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

자 이제, 테스트 코드를 짜보겠습니다. `UserControllerTest`에 다음 코드를 추가해 주세요.

mvc/src/test/java/com/gurumee/mvc/user/UserControllerTest.java
```java
package com.gurumee.mvc.user;

// import

@RunWith(SpringRunner.class)
@WebMvcTest(UserController.class)
public class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        mockMvc.perform( get("/hello") )
            .andExpect( status().isOk() )
            .andExpect( content().string("hello") )
        ;
    }

    //아래 코드가 추가 코드입니다.
    @Test
    public void 유저_생성_JSON() throws Exception {
        String userJson = "{\"username\": \"keesun\", \"password\": \"12345\"}";

        mockMvc.perform( post("/user")
            .contentType(MediaType.APPLICATION_JSON_UTF8)
            .accept(MediaType.APPLICATION_JSON_UTF8)
            .content(userJson)
        )
        .andExpect( status().isOk() )
        .andExpect( jsonPath("$.username", is(equalTo("keesun"))) )
        .andExpect( jsonPath("$.password", is(equalTo("12345"))) )
        .andDo( print() )
                ;
    }
}
```

테스트 코드는 "/user" 에 POST 요청을 보내며, content-type을 application/json, accept-header도 application/json, 그리고 JSON 문자열을 content로 보냅니다. 이는 사용자 요청, 서버 응답을 JSON 형식으로 하고 `userJson`을 요청 본문으로 보내겠다는 것입니다. 역시 이 테스트도 깔끔하게 돌아갑니다.

이게 가능한 것은 스프링 부트에서 자동으로 주입한 `WebMvcAutoConfiurer`가 여기에 대한 빈 설정을 해 두었기 때문입니다. 만약 컴포지션 타입(User 클래스 같은)이라면, `JsonMessageConverter`가 문자열이라면, `StringMessageConverter`가 동작하게 됩니다. 


## ViewResolver

또한 위의 코드가 가능한 것은  `HttpMessageConverter` 이외에 "컨텐츠 네고시에이션 뷰 리졸버"라는 녀석이 JSON에 대한 `ViewResolver`를 자동으로 등록해줬기 때문입니다.
스프링 부트 애플리케이션은 별 다른 설정이 없어도 들어오는 요청 헤더에 따라 응답이 달라지게 할 수 있습니다. 결국 `ViewResolver`란 요청(accept-header)에 대한 적절한 뷰를 찾아내는 녀석인 것이죠.

위의 설명은 쉽게 말해 JSON 방식 말고도 얼마든지 개발자가 원하는 방식으로 응답을 바꿔줄 수 있다는 뜻입니다. 이번엔 XML 응답으로 만들어보겠습니다. 먼저 테스트 코드에 다음 코드를 추가해주세요.

mvc/src/test/java/com/gurumee/mvc/user/UserControllerTest.java
```java
package com.gurumee.mvc.user;

// import

@RunWith(SpringRunner.class)
@WebMvcTest(UserController.class)
public class UserControllerTest {

    //same code

    //아래 코드가 추가 코드입니다.
    @Test
    public void 유저_생성_XML() throws Exception {
        String userJson = "{\"username\": \"keesun\", \"password\": \"12345\"}";

        mockMvc.perform( post("/user")
                .contentType(MediaType.APPLICATION_JSON_UTF8)
                .accept(MediaType.APPLICATION_XML)
                .content(userJson)
        )
        .andExpect( status().isOk() )
        .andExpect( xpath("/User/username").string("keesun") )
        .andExpect( xpath("/User/password").string("12345") )
        .andDo( print() )
        ;
    }
}
```

위 테스트 코드는 "유저_생성_JSON" 방식과 같은데, 응답 본문을 XML 형식으로 보내준다는 차이점이 있습니다. 실제 이 테스트를 돌려보면 406 에러가 뜹니다. 이 에러는 애플리케이션 내에 적절한 응답 뷰가 없을 때 발생합니다. 이것은 다음 의존성만 추가하면, 해결할 수 있습니다.

mvc/pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- same code -->

    <dependencies>
        <!-- same code -->
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
            <version>2.9.6</version>
        </dependency>
    </dependencies>

    <!-- same code -->

</project>
```

테스트를 돌려보세요. 통과할 것입니다. 이게 가능한 이유는, 만약 위의 의존성이 들어온 경우에, 그 의존성 코드들을 이용하여 스프링 부트는 XML에 대한 뷰 리졸버를 등록하기 때문입니다.


## 정적 리소스 지원



## 웹 JAR



## index 페이지와 파비콘



## Thymeleaf



## HtmlUnit



## ExceptionHandler



## HATEOAS



## CORS


