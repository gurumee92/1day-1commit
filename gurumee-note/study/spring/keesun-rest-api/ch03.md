HATEOAS와 Self-Descriptive Message 적용
====================

> 백기선님의 인프런 강좌 "스프링 기반 REST API 개발"을 보고 정리한 문서들입니다. 강의는 개발자의 피와 땀의 결실이라고 생각합니다. 꼭 인프런 강의를 듣고, 참고 사항으로 보셨으면 좋겠습니다.

Contents
--------------
1. Spring HATEOAS 소개
2. Spring HATEOAS 적용
3. Spring REST Docs 소개
4. Spring REST Docs 적용
5. Spring REST Docs 각종 문서 조각 생성하기
6. Spring REST Docs 문서 빌드하기
7. 테스트용 DB와 설정 분리하기
8. API 인덱스 페이지 만들기

* [소스코드](https://github.com/gurumee92/keesun-rest-api) 브랜치: ENH-03

## Spring HATEOAS 소개

`HATEOAS`의 목적은 `REST API`를 만들때 _links 등 표현하는데 보다 유용한 유틸성 메소드들을 제공해주는 스프링 프로젝트입니다. 예를 들어볼까요?

```HTTP
GET /accounts/12345
Host: bank.example.com
Accept: applcation/hal+json
```

이런 HTTP 요청을 받았을 때, REST API는 어떤 결과를 주어야 할까요? 보통 은행이라면 계좌에 대해 잔고가 있어야 하며, 해당하는 행위, 그러니까 입/출금, 송금, 삭제 등의 행위 들이 표현되어야 합니다.

```json
{
    "account_number": 12345,
    "balance": {
        "value": 100.00,
        "currency": "usd"
    },
    "_links": {
        "self": "https://bank.example.com/accounts/12345",
        "profile": "https://bank.example.com/api/accounts/",
        "deposit": "https://bank.example.com/accounts/12345/deposit",
        "withdraw": "https://bank.example.com/accounts/12345/withdraw",
        "tranfer": "https://bank.example.com/accounts/12345/tranfer",
        "close": "https://bank.example.com/accounts/12345/close"
    }
}
```

만약 잔고가 -라면 어떻게 변해야 할까요? 출금, 송금, 삭제가 되면 안되겠지요? 입금만 가능하게 바뀌어야 합니다. 결과는 이렇게 바뀝니다.

```json
{
    "account_number": 12345,
    "balance": {
        "value": -5.0,
        "currency": "usd"
    },
    "_links": {
        "self": "https://bank.example.com/accounts/12345",
        "profile": "https://bank.example.com/api/accounts/",
        "deposit": "https://bank.example.com/accounts/12345/deposit"
    }
}
```

REST API 는 `resources`, `links` 이렇게 2가지로 나뉩니다. `links`는 보통 다음의 정보들을 지닙니다.

* HREF
* REL
    * self
    * profile
    * 해당 행위들

`Spring HATEOAS` 이런 링크들을 보다 효율적으로 만들 수 있게 도와줍니다. 이제 적용하면서 찬찬히 알아보도록 하겠습니다.

## Spring HATEOAS 적용

자 이제 적용하도록 하겠습니다. 위에서 말했듯 HATEOAS 하려면 링크 정보를 주어야 합니다. HAL 스펙에서는 "_links" 프로퍼티를 주는데, 보통 다음과 같이 구성됩니다.

* `self`: 자신을 가리키는 URL 정보가 있습니다.
* `profile`: 자신을 알려주는 api 페이지 URL 정보가 있습니다.
* 기타 : 그 리소스가 할 수 있는 행위들에 대한 URL 정보가 있습니다.

자 테스트 코드를 다음과 같이 바꿔봅시다.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class EventControllerTest {

    /* same */

    @Test
    public void 이벤트_생성_정상_입력_OK() throws Exception {

        EventDto eventDto = EventDto.builder()
                .name("Spring")
                .description("REST API Development with Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2019, 7, 23, 9, 0, 0))
                .closeEnrollmentDateTime(LocalDateTime.of(2019, 8, 1, 23, 59, 0))
                .beginEventDateTime(LocalDateTime.of(2019, 8, 5, 11, 0, 0))
                .endEventDateTime(LocalDateTime.of(2019, 8, 5, 14, 0, 0))
                .basePrice(100)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .build();

        mockMvc.perform(
                post("/api/events")
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .accept(MediaTypes.HAL_JSON)
                    .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isCreated())
        .andExpect(jsonPath("id").exists())
        .andExpect(header().exists(HttpHeaders.LOCATION))
        .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_UTF8_VALUE))
        .andExpect(jsonPath("free").value(false))
        .andExpect(jsonPath("offline").value(true))
        .andExpect(jsonPath("eventStatus").value(EventStatus.DRAFT.name()))
        // 아래 코드가 추가된 부분입니다.
        .andExpect(jsonPath("_links.self").exists())
//                .andExpect(jsonPath("_links.profile").exists())
        .andExpect(jsonPath("_links.query-events").exists())
        .andExpect(jsonPath("_links.update-event").exists())
        ;
    }

    /* same */
}
```

추가된 코드를 보시면, 아직 `Spring REST Docs`를 적용하지 않았기 때문에 `_links.profile` 정보를 주석 처리를 해두었습니다. 나머지는 `self` 그리고 이벤트 목록을 조회할 수 있는 `query-events(GET: /api/events)` 그리고 이벤트 한 건을 수정할 수 있는 `update-event(PUT /api/events/:id)` 링크 정보가 있는지 테스트하는 코드입니다. 이제 테스트를 돌려보면 실패하게 됩니다. 어떻게 적용할까요. 

먼저 우리는 `EventResource`를 구현해야 합니다.

src/main/java/projcet/eventes/EventResource.java
```java
package com.gurumee.keesunrestapi.events;

import org.springframework.hateoas.Link;
import org.springframework.hateoas.Resource;

import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;

public class EventResource extends Resource<Event> {

    public EventResource(Event content, Link... links) {
        super(content, links);
    }
}
```

    참고!
    이 방법은 일종의 편법입니다. 정석 방법은 영상 강의에 잘 나와있습니다. 강의를 참고해주세요!

그 후, `EventController` 코드를 다음과 같이 수정해주세요.

src/main/java/project/events/EventController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */
@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    /* same */

    @PostMapping
    public ResponseEntity createEvent(@RequestBody @Valid EventDto eventDto, Errors errors) {

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().body(errors);
        }

        eventValidator.validate(eventDto, errors);

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().body(errors);
        }

        Event event = modelMapper.map(eventDto, Event.class);
        Event newEvent = eventRepository.save(event);
        newEvent.update();
        // 아래 코드는 수정된 부분
        ControllerLinkBuilder selfLinkBuilder = linkTo(EventController.class).slash(newEvent.getId());
        URI uri = selfLinkBuilder.toUri();

        EventResource eventResource = new EventResource(newEvent);
        eventResource.add(linkTo(EventController.class).withRel("query-events"));
        eventResource.add(selfLinkBuilder.withSelfRel());
        eventResource.add(selfLinkBuilder.withRel("update-event"));
        return ResponseEntity.created(uri).body(eventResource);
    }
}
```

코드를 하나 하나 살펴보면, "/api/events/:id" 부분에 대한 경로를 재활용하기 위해서 `linkTo(EventController.class).slash(newEvent.getId())`를 변수로 빼두었습니다. 그 후 하는 일은 간단합니다. 리소스 객체를 만들어준 후, 해당 링크 정보를 넣어주면 됩니다. 생성 구문 밑에 3줄이 바로 링크 정보를 추가하는 코드입니다.

## Spring REST Docs 소개

`Spring REST Docs` 프로젝트는 `Spring MVC Test`를 사용해서 API 문서를 제공해주는 라이브러리입니다. 흔히 말하는 문서 자동화를 해주는 건데 **테스트 코드 기반**으로 문서를 만들어 주는 기특한 녀석입니다. `마크다운(.md)` 형식과 `아스키독(.adoc)` 형식이 있는데 보통은 후자를 많이 사용합니다. 

또한 스프링 부트에서는 `@AutoConfigureRestDocs` 애노테이션으로 간단하게 테스트 코드 기반으로 적용이 가능합니다. 이는 적용하면서 찬찬히 살펴보도록 하겠습니다.

## Spring REST Docs 적용

자 바로 적용해보도록 하겠습니다. 먼저 `EventControllerTest`를 다음과 같이 수정해주세요.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureRestDocs //REST Docs 설정
public class EventControllerTest {

    /* same */

    @Test
    public void 이벤트_생성_정상_입력_OK() throws Exception {

        EventDto eventDto = EventDto.builder()
                .name("Spring")
                .description("REST API Development with Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2019, 7, 23, 9, 0, 0))
                .closeEnrollmentDateTime(LocalDateTime.of(2019, 8, 1, 23, 59, 0))
                .beginEventDateTime(LocalDateTime.of(2019, 8, 5, 11, 0, 0))
                .endEventDateTime(LocalDateTime.of(2019, 8, 5, 14, 0, 0))
                .basePrice(100)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .build();

        mockMvc.perform(
                post("/api/events")
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .accept(MediaTypes.HAL_JSON)
                    .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isCreated())
        .andExpect(jsonPath("id").exists())
        .andExpect(header().exists(HttpHeaders.LOCATION))
        .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_UTF8_VALUE))
        .andExpect(jsonPath("free").value(false))
        .andExpect(jsonPath("offline").value(true))
        .andExpect(jsonPath("eventStatus").value(EventStatus.DRAFT.name()))
        .andExpect(jsonPath("_links.self").exists())
        .andExpect(jsonPath("_links.query-events").exists())
        .andExpect(jsonPath("_links.update-event").exists())
        //추가 구문
        .andDo(document("create-event")); 
        ;
    }
    /* same */
}
```

앞서 말했듯이 `@AutoConfigureRestDocs` 애노테이션을 가지고 테스트 코드를 기반으로 문서를 작성하게끔 만들어두었습니다. 그리고 테스트 코드에서 `MockMvc` 객체의 테스트를 날릴 때 마지막으로 `.andDo(document("create-event"));`를 작성하면 됩니다. 테스트를 돌려보세요!

그러면 target/generated-snippets 디렉토리가 생겼고 우리가 지정한 "create-event" 디렉토리가 하위에 생겼습니다. 그리고 기본적인 `adoc` 파일들이 생겼습니다. 이들을 보시면 요청, 응답에 대해서 간단히 설명하고 있습니다. 그러나 JSON 표현이 한 줄로 되어 있어 보기가 힘듭니다. 이를 고쳐보도록 하겠습니다.

먼저 src/test/java/project 밑에 commons 디렉토리를 생성합니다. 그 후 `RestDocsConfiguration`을 생성한 후 다음과 같이 작성합니다.

src/test/java/project/commons/RestDocsConfiguration.java
```java
package com.gurumee.keesunrestapi.commons;

import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;

import static org.springframework.restdocs.operation.preprocess.Preprocessors.prettyPrint;

@TestConfiguration
public class RestDocsConfiguration {

    @Bean
    public RestDocsMockMvcConfigurationCustomizer restDocsMockMvcConfigurationCustomizer() {
        return configurer -> configurer.operationPreprocessors()
                .withRequestDefaults(prettyPrint())
                .withResponseDefaults(prettyPrint());
    }
}
```

이렇게 해두면, 요청/응답의 결과를 이쁘게 출력시켜줍니다. 이제 `EventControllerTest`를 다음과 같이 수정해주세요.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureRestDocs 
@Import(RestDocsConfiguration.class) //우리가 설정한 Configuration 임포트
public class EventControllerTest {

    /* same */
}
```

`@Import(RestDocsConfiguration.class)` 이 구문은 주석에 작성한 그대로 우리가 설정한 빈을 테스트 코드 시에 등록시켜주는 역할을 합니다. 이제 테스트를 돌려보고 결과물(target/generated-snippets/create-event/*.adoc)을 확인해보면, 응답/요청에 대한 JSON 형식이 이쁘게 출력되는 것을 볼 수 있습니다.

## Spring REST Docs 각종 문서 조각 생성하기

자 이번에는 links, request-headers, request-fields, response-headers, response-fields 정보를 문서 조각으로 만들어봅시다. 테스트 코드를 다음과 같이 수정해주세요.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureRestDocs 
@Import(RestDocsConfiguration.class) //우리가 설정한 Configuration 임포트
public class EventControllerTest {

    /* same */

    @Test
    public void 이벤트_생성_정상_입력_OK() throws Exception {

        EventDto eventDto = EventDto.builder()
                .name("Spring")
                .description("REST API Development with Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2019, 7, 23, 9, 0, 0))
                .closeEnrollmentDateTime(LocalDateTime.of(2019, 8, 1, 23, 59, 0))
                .beginEventDateTime(LocalDateTime.of(2019, 8, 5, 11, 0, 0))
                .endEventDateTime(LocalDateTime.of(2019, 8, 5, 14, 0, 0))
                .basePrice(100)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .build();

        mockMvc.perform(
                post("/api/events")
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .accept(MediaTypes.HAL_JSON)
                    .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isCreated())
        .andExpect(jsonPath("id").exists())
        .andExpect(header().exists(HttpHeaders.LOCATION))
        .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_UTF8_VALUE))
        .andExpect(jsonPath("free").value(false))
        .andExpect(jsonPath("offline").value(true))
        .andExpect(jsonPath("eventStatus").value(EventStatus.DRAFT.name()))
        .andExpect(jsonPath("_links.self").exists())
        .andExpect(jsonPath("_links.query-events").exists())
        .andExpect(jsonPath("_links.update-event").exists())
        //아래 "create-evnt", ... 가 추가되었습니다.
        .andDo(document("create-event",
                links(
                        linkWithRel("self").description("link to self"),
                        linkWithRel("query-events").description("link to query events"),
                        linkWithRel("update-event").description("link to update event")
                ),
                requestHeaders(
                        headerWithName(HttpHeaders.ACCEPT).description("request header accept"),
                        headerWithName(HttpHeaders.CONTENT_TYPE).description("request header content type")
                ),
                requestFields(
                        fieldWithPath("name").description("Name of new event: String"),
                        fieldWithPath("description").description("Description of new event: String"),
                        fieldWithPath("beginEnrollmentDateTime").description("Begin Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("closeEnrollmentDateTime").description("End Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("beginEventDateTime").description("Begin DateTime of new event: DateTime"),
                        fieldWithPath("endEventDateTime").description("End DateTime of new event: DateTime"),
                        fieldWithPath("location").description("Location of new event: String"),
                        fieldWithPath("basePrice").description("Base Price of new event: Int"),
                        fieldWithPath("maxPrice").description("Max Price of new event: Int"),
                        fieldWithPath("limitOfEnrollment").description("Limit Of Enrollment of new event: Int")
                ),
                responseHeaders(
                        headerWithName(HttpHeaders.LOCATION).description("response header location"),
                        headerWithName(HttpHeaders.CONTENT_TYPE).description("response header content type")
                ),
                responseFields(
                        fieldWithPath("id").description("Id of new event: Int"),
                        fieldWithPath("name").description("Name of new event: String"),
                        fieldWithPath("description").description("Description of new event: String"),
                        fieldWithPath("beginEnrollmentDateTime").description("Begin Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("closeEnrollmentDateTime").description("End Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("beginEventDateTime").description("Begin DateTime of new event: DateTime"),
                        fieldWithPath("endEventDateTime").description("End DateTime of new event: DateTime"),
                        fieldWithPath("location").description("Location of new event: String"),
                        fieldWithPath("basePrice").description("Base Price of new event: Int"),
                        fieldWithPath("maxPrice").description("Max Price of new event: Int"),
                        fieldWithPath("limitOfEnrollment").description("Limit Of Enrollment of new event: Int"),
                        fieldWithPath("offline").description("Is Offline of new event: boolean"),
                        fieldWithPath("free").description("Is Free Of Enrollment of new event: Int"),
                        fieldWithPath("eventStatus").description("Event Status Of Enrollment of new event: String"),
                        fieldWithPath("_links.self.href").description("Self URL of new event: url"),
                        fieldWithPath("_links.query-events.href").description("Query Events URL Enrollment of new event: url"),
                        fieldWithPath("_links.update-event.href").description("Update Event Of Enrollment of new event: url")
                )
        ))
        ;
    }

    /* same */
}
```

굉장히 이름이 명시적이라, 딱히 드릴 말씀이 없네요. 주의할 점은 `requestFields`, `responseFields` 메소드 내에서 가지고 있는 모든 필드들에 대해서 `description`을 붙여주어야 한다는 것입니다. 심지어 `_links`에 있는 정보들까지도 말이죠. 

이런 부분을 안해주게끔 `relaxedRequestFields`, `relaxedResponseFields`들도 지원하지만, 이런 것들은 조금 위험합니다. 가령, 어떤 필드에 대해서 테스트를 깜빡 안하고, 위의 메소드들을 썼다면, 테스트 내에서는 해당 필드에 대한 테스트가 이루어지지 않습니다. 이런 것들이 실제로 러닝 타임에 큰 오류를 만들게 됩니다. 그래서 귀찮더라도 이런 코드들을 꼼꼼히 만들어 주세요!

## Spring REST Docs 문서 빌드하기

자 이제 REST Docs 문서를 빌드하고 self-descriptive message 한 API를 만들기 위해 profile 링크를 달아봅시다. 먼저 `pom.xml` 을 다음처럼 수정해주세요.

pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<!-- 이전과 동일 -->

	<build>
		<plugins>
			<plugin>
				<groupId>org.asciidoctor</groupId>
				<artifactId>asciidoctor-maven-plugin</artifactId>
				<version>1.5.3</version>
				<executions>
					<execution>
						<id>generate-docs</id>
						<phase>prepare-package</phase>
						<goals>
							<goal>process-asciidoc</goal>
						</goals>
						<configuration>
							<backend>html</backend>
							<doctype>book</doctype>
						</configuration>
					</execution>
				</executions>
				<dependencies>
					<dependency>
						<groupId>org.springframework.restdocs</groupId>
						<artifactId>spring-restdocs-asciidoctor</artifactId>
						<version>2.0.2.RELEASE</version>
					</dependency>
				</dependencies>
			</plugin>
			<plugin>
				<artifactId>maven-resources-plugin</artifactId>
				<version>2.7</version>
				<executions>
					<execution>
						<id>copy-resources</id>
						<phase>prepare-package</phase>
						<goals>
							<goal>copy-resources</goal>
						</goals>
						<configuration>
							<outputDirectory>
								${project.build.outputDirectory}/static/docs
							</outputDirectory>
							<resources>
								<resource>
									<directory>
										${project.build.directory}/generated-docs
									</directory>
								</resource>
							</resources>
						</configuration>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
```

이번 설정은 메이븐 플러그인 설정입니다. 먼저 첫 번째 플러그인이 테스트 코드 기반으로 ascii doc 스니펫들을 만들고 두 번째 플러그인이 빌드 시 static/docs/~.html 형식으로 우리가 만들어준 REST Docs 를 만들어줍니다. 세 번째 플러그인인 스프링 부트 플러그인이 별다른 설정 안해도 docs/index.html 로 접근이 가능하게 만들어줍니다.

이제 메인 디렉토리 밑에 `asciidoc` 디렉토리를 만들고 `index.adoc`을 다음처럼 만들어주세요. 

src/main/asciidoc/index.adoc
```adoc
= REST API Guide
구르미;
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 4
:sectlinks:
:operation-curl-request-title: Example request
:operation-http-response-title: Example response

[[overview]]
= 개요

[[overview-http-verbs]]
== HTTP 동사

본 REST API에서 사용하는 HTTP 동사(verbs)는 가능한한 표준 HTTP와 REST 규약을 따릅니다.

|===
| 동사 | 용례

| `GET`
| 리소스를 가져올 때 사용

| `POST`
| 새 리소스를 만들 때 사용

| `PUT`
| 기존 리소스를 수정할 때 사용

| `PATCH`
| 기존 리소스의 일부를 수정할 때 사용

| `DELETE`
| 기존 리소스를 삭제할 떄 사용
|===

[[overview-http-status-codes]]
== HTTP 상태 코드

본 REST API에서 사용하는 HTTP 상태 코드는 가능한한 표준 HTTP와 REST 규약을 따릅니다.

|===
| 상태 코드 | 용례

| `200 OK`
| 요청을 성공적으로 처리함

| `201 Created`
| 새 리소스를 성공적으로 생성함. 응답의 `Location` 헤더에 해당 리소스의 URI가 담겨있다.

| `204 No Content`
| 기존 리소스를 성공적으로 수정함.

| `400 Bad Request`
| 잘못된 요청을 보낸 경우. 응답 본문에 더 오류에 대한 정보가 담겨있다.

| `404 Not Found`
| 요청한 리소스가 없음.
|===

[[overview-errors]]
== 오류

에러 응답이 발생했을 때 (상태 코드 >= 400), 본문에 해당 문제를 기술한 JSON 객체가 담겨있다. 에러 객체는 다음의 구조를 따른다.

include::{snippets}/errors/response-fields.adoc[]

예를 들어, 잘못된 요청으로 이벤트를 만들려고 했을 때 다음과 같은 `400 Bad Request` 응답을 받는다.

include::{snippets}/errors/http-response.adoc[]

[[overview-hypermedia]]
== 하이퍼미디어

본 REST API는 하이퍼미디어와 사용하며 응답에 담겨있는 리소스는 다른 리소스에 대한 링크를 가지고 있다.
응답은 http://stateless.co/hal_specification.html[Hypertext Application from resource to resource. Language (HAL)] 형식을 따른다.
링크는 `_links`라는 키로 제공한다. 본 API의 사용자(클라이언트)는 URI를 직접 생성하지 않아야 하며, 리소스에서 제공하는 링크를 사용해야 한다.

[[resources]]
= 리소스

[[resources-index]]
== 인덱스

인덱스는 서비스 진입점을 제공한다.


[[resources-index-access]]
=== 인덱스 조회

`GET` 요청을 사용하여 인덱스에 접근할 수 있다.

operation::index[snippets='response-body,http-response,links']

[[resources-events]]
== 이벤트

이벤트 리소스는 이벤트를 만들거나 조회할 때 사용한다.

[[resources-events-list]]
=== 이벤트 목록 조회

`GET` 요청을 사용하여 서비스의 모든 이벤트를 조회할 수 있다.

operation::get-events[snippets='response-fields,curl-request,http-response,links']

[[resources-events-create]]
=== 이벤트 생성

`POST` 요청을 사용해서 새 이벤트를 만들 수 있다.

operation::create-event[snippets='request-fields,curl-request,http-request,request-headers,http-response,response-headers,response-fields,links']

[[resources-events-get]]
=== 이벤트 조회

`Get` 요청을 사용해서 기존 이벤트 하나를 조회할 수 있다.

operation::get-event[snippets='request-fields,curl-request,http-response,links']

[[resources-events-update]]
=== 이벤트 수정

`PUT` 요청을 사용해서 기존 이벤트를 수정할 수 있다.

operation::update-event[snippets='request-fields,curl-request,http-response,links']
```

이것을 알 수 있게끔 링크를 걸어주셨으면 좋았겠지만... 없으니 저도 생략 ㅎㅎ 이제 IDE 에서 maven package 플러그인 기능을 눌러주세요. 그럼 `target/classes/static/index.html`이 만들어질 겁니다. 실제 애플리케이션을 구동하고 `http://localhost:8080/docs/index.html`에 접속하면 우리가 만든 REST Docs가 보입니다.

이제 우리 API를 **self-descriptive message**한 API가 되게끔 profile 링크를 달아봅시다. 먼저 테스트 코드를 작성하겠습니다. `EventControllerTest`를 다음처럼 수정해주세요.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureRestDocs
@Import(RestDocsConfiguration.class)
public class EventControllerTest {

    /* 이전과 동일 */

    @Test
    public void 이벤트_생성_정상_입력_OK() throws Exception {

        /* 이전과 동일 */

        mockMvc.perform(
                post("/api/events")
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .accept(MediaTypes.HAL_JSON)
                    .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isCreated())
        /* 이전과 동일 */
        .andDo(document("create-event",
                links(
                        linkWithRel("self").description("link to self"),
                        linkWithRel("query-events").description("link to query events"),
                        linkWithRel("update-event").description("link to update event"),
                        //추가 코드
                        linkWithRel("profile").description("link to profile")
                ),
                /* 이전과 동일 */
                responseFields(
                        fieldWithPath("id").description("Id of new event: Int"),
                        /* 이전과 동일 */
                        fieldWithPath("_links.update-event.href").description("Update Event Of Enrollment of new event: url"),

                        //추가 코드
                        fieldWithPath("_links.profile.href").description("Profile of new event: url")
                )
        ))
        ;
    }

    /* 이전과 동일 */
}
```

후~ 이제 소스코드 올리기가 벅차군요. `이벤트_생성_정상_입력_OK` 테스트 메소드에서 links, responseFields 밑에 profile 정보에 대한 테스트를 추가하면 됩니다. 자 이제 테스트가 깨질 겁니다. 이제 컨트롤러 코드를 작성해보도록 하겠습니다.

src/main/java/project/events/EventController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */ 

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    /* 이전과 동일 */ 

    @PostMapping
    public ResponseEntity createEvent(@RequestBody @Valid EventDto eventDto, Errors errors) {

        /* 이전과 동일 */ 
        eventResource.add(new Link("/docs/index.html#resources-events-create").withRel("profile"));
        return ResponseEntity.created(uri).body(eventResource);
    }
}
```

자 이제 테스트를 돌려보면 무사히 통과하는 것을 알 수 있습니다.


## 테스트용 DB와 설정 분리하기


## API 인덱스 페이지 만들기

