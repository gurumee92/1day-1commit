이벤트 조회 및 수정 REST API 개발
===================

> 백기선님의 인프런 강좌 "스프링 기반 REST API 개발"을 보고 정리한 문서들입니다. 강의는 개발자의 피와 땀의 결실이라고 생각합니다. 꼭 인프런 강의를 듣고, 참고 사항으로 보셨으면 좋겠습니다.

Contents
--------------

1. 이벤트 목록 조회 API 구현하기
2. 단일 이벤트 조회 API 구현하기
3. 이벤트 수정 API 구현하기
4. 테스트 코드 리팩토링


## 이벤트 목록 조회 API 구현하기

자 이번에는 이벤트 목록을 조회할 수 있는 API를 만들어보겠습니다. 바로 테스트부터 시작하도록하죠. 그러기 전에 `EventControllerTest`내에서 목록을 30개 만드는 메소드부터 만들도록 하겠습니다.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureMockMvc
@AutoConfigureRestDocs
@Import(RestDocsConfiguration.class)
public class EventControllerTest {

    /* 이전과 동일 */
    @Autowired
    private EventRepository eventRepository;

    /* 이전과 동일 */

    private Event generateEvent(int i) {
        Event event = Event.builder()
                .name("event" + i)
                .description("test event")
                .build();
        return this.eventRepository.save(event);
    }
}
```

이것은 인덱스 i에 대해서 event$i 를 갖는 이벤트를 하나 생성하는 메소드입니다. 이것을 테스트 메소드 내에서 연속적으로 30개를 만들 것입니다. 계속해서 테스트 코드를 작성해주세요. 우리는 GET /api/events 에 대해서 파라미터로 page, sort, 등의 정보를 넣고 싶다고 가정하겠습니다. 테스트 코드를 다음과 같이 작성해주세요. 

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureMockMvc
@AutoConfigureRestDocs
@Import(RestDocsConfiguration.class)
public class EventControllerTest {

    /* 이전과 동일 */
     @Test
    public void 이벤트_30_10개씩_두번째_페이지_조회하기() throws Exception{
        IntStream.range(0, 30).forEach(this::generateEvent);

        mockMvc.perform(
                get("/api/events")
                .param("page", "1")
                .param("size", "10")
                .param("sort", "name,DESC")
        )
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(jsonPath("page").exists())
        .andExpect(jsonPath("_embedded.eventList[0]._links.self").exists())
        .andExpect(jsonPath("_links.self").exists())
        .andExpect(jsonPath("_links.profile").exists())
        .andDo(document("query-events"))
        ;
    }
}
```

메소드 명대로 30개의 이벤트 목록에서 10개씩 페이지를 묶고 두 번째 페이지를 조회하는 테스트 코드입니다. 파라미터 정보로 page=1, size=10, sort=name,DESC 를 준 것입니다. 그리고 원래대로 하려면 andDo 이하에 무수히 많은 REST Docs 스니펫을 만드는 정보를 주어야 하지만 생략하도록 하겠습니다. 이제 테스트를 돌려보면 실패합니다. 바로 컨트롤러 코드를 작성하겠습니다.

src/main/java/project/events/EvetnController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    /* 이전과 동일 */

    @GetMapping
    public ResponseEntity queryEvents(Pageable pageable, PagedResourcesAssembler<Event> assembler) {
        Page<Event> events = this.eventRepository.findAll(pageable);
        PagedResources<Resource<Event>> resources = assembler.toResource(events, e -> new EventResource(e));
        resources.add(new Link("/docs/index.html#resources-events-list").withRel("profile"));
        resources.add(linkTo(EventController.class).withRel("query-events"));
        return ResponseEntity.ok(resources);
    }
}
```

스프링에서 주어지는 `Pageable` 클래스를 이용하면 손쉽게 page, sort, size 등의 정보를 얻을 수 있습니다. 다만 이들은 리소스화되지 않기 때문에 적절히 리소스화하지 않으면 "pageable" 이란 프로퍼티에 담기게 됩니다. 그래서 `PagedResourcesAssembler`로 리소스화를 해줍니다. 그 후 우리가 필요한 HATEOAS 링크 정보를 적절히 주면 됩니다.


## 단일 이벤트 조회 API 구현하기

이제 단일 이벤트 조회 API를 구현 해보겠습니다. 여느 때 처럼 테스트 코드부터 진행하도록 하겠습니다. `EventControllerTest`에 다음의 2개의 테스트 메소드를 추가해주세요.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureMockMvc
@AutoConfigureRestDocs
@Import(RestDocsConfiguration.class)
public class EventControllerTest {

    /* 이전과 동일 */

    @Test
    public void 이벤트_1개_조회하기_있을_때() throws Exception{
        Event event = this.generateEvent(100);

        mockMvc.perform(
                get("/api/events/{id}", event.getId())
        )
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(jsonPath("id").exists())
        .andExpect(jsonPath("name").exists())
        .andExpect(jsonPath("description").exists())
        .andExpect(jsonPath("_links.self").exists())
        .andExpect(jsonPath("_links.profile").exists())
        .andDo(document("get-an-event"))
        ;
    }

    @Test
    public void 이벤트_1개_조회하기_없을_때() throws Exception{

        mockMvc.perform(
                get("/api/events/{id}", 100)
        )
        .andDo(print())
        .andExpect(status().isNotFound())
        ;
    }
}
```

자 이제, 바로 `EventController`를 수정하도록 하겠습니다.

src/main/java/project/events/EventController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    /* 이전과 동일 */

    @GetMapping("/{id}")
    public ResponseEntity queryEvent(@PathVariable Integer id) {
        Optional<Event> optionalEvent = this.eventRepository.findById(id);

        if (optionalEvent.isEmpty()){
            return ResponseEntity.notFound().build();
        }

        Event event = optionalEvent.get();
        EventResource resource = new EventResource(event);
        resource.add(new Link("/docs/index.html#resources-events-get").withRel("profile"));
        resource.add(linkTo(EventController.class).withRel("get-an-event"));
        return ResponseEntity.ok(resource);

    }
}
```

`id`를 URL 패스로 넘겨주었고 그 URL에 매핑시킬 메소드를 추가하였습니다. 그리고 해당 id의 이벤트를 못 찾으면 404에러를 잘 찾아내면, HATEOAS 링크 정보들과 함께 `EventResource`를 넘겨주었습니다. 이로써 단일 이벤트 조회 API도 완료하였습니다. 이전에가 너무 빡세서 그렇지 한 번 하면 금방 금방 하네요.


## 이벤트 수정 API 구현하기


## 테스트 코드 리팩토링

