이벤트 생성 API 개발 #2
===================

> 백기선님의 인프런 강좌 "스프링 기반 REST API 개발"을 보고 정리한 문서들입니다. 강의는 개발자의 피와 땀의 결실이라고 생각합니다. 꼭 인프런 강의를 듣고, 참고 사항으로 보셨으면 좋겠습니다.

Contents
--------------
1. Bad Request 처리
2. Bad Request 응답
3. 비지니스 로직 적용
4. 매개 변수를 이용한 테스트

* [소스코드](https://github.com/gurumee92/keesun-rest-api) 브랜치: ENH-02

## Bad Request 처리

우리가 만날 수 있는 Bad Request는 테스트 코드보다 더 다양합니다. 가장 크게 다음이 있을 수 있습니다.

1. 값들이 빈 경우
2. 로직 상 들어오면 안되는 값들일 경우

자 먼저 값들이 빈 객체가 들어왔을 때 Bad Request를 처리해보도록 하겠습니다.

src/test/java/project/events/EventController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class EventControllerTest {

    /* same code */

    @Test
    public void 이벤트_생성_잘못된_입력_부족한_필드를_가진_객체가_들어올_때_BAD_REQUEST() throws Exception {

        EventDto eventDto = EventDto.builder().build();

        mockMvc.perform(
                post("/api/events")
                        .contentType(MediaType.APPLICATION_JSON_UTF8)
                        .accept(MediaTypes.HAL_JSON)
                        .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isBadRequest())
        ;
    }
}
```

테스트를 돌려볼까요? 이 경우 값은 비었지만 모르는 프로퍼티가 없기 때문에 201 응답이 나옵니다. 우리는 `JSR-330`을 이용하여 이 값들에 대해 검증할 수 있습니다. `EventDto`를 다음과 같이 변경해주세요.

src/main/java/project/events/EventDto.java
```java
package com.gurumee.keesunrestapi.events;


import lombok.*;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import java.time.LocalDateTime;

@Builder @AllArgsConstructor @NoArgsConstructor
@Data
public class EventDto {
    @NotEmpty
    private String name;
    @NotNull
    private String description;
    @NotNull
    private LocalDateTime beginEnrollmentDateTime;
    @NotNull
    private LocalDateTime closeEnrollmentDateTime;
    @NotNull
    private LocalDateTime beginEventDateTime;
    @NotNull
    private LocalDateTime endEventDateTime;
    @NotNull
    private String location;
    @Min(0)
    private int basePrice;
    @Min(0)
    private int maxPrice;
    @Min(0)
    private int limitOfEnrollment;
}
```
`@NotEmpty` 애노테이션은 문자열이 빈 문자열인지 여부를 검증합니다. `@NotNull` 애노테이션은 객체가 널이 아닌지를 검증합니다. `@Min`는 정수형 데이터가 입력한 값보다 높은지를 검증합니다. 여기서 0을 주었기 때문에 `basePrice, maxPrice, limitOfEnrollment` 필드들은 최소 0보다 커야 합니다. 이제 `EventController`를 다음과 같이 수정해주세요.

src/main/java/project/events/EventController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    /* same */

    @PostMapping
    public ResponseEntity createEvent(@RequestBody @Valid EventDto eventDto, Errors errors) {

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().build();
        }

        eventValidator.validate(eventDto, errors);

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().build();
        }

        Event event = modelMapper.map(eventDto, Event.class);
        Event newEvent = eventRepository.save(event);
        URI uri = linkTo(EventController.class).slash(newEvent.getId()).toUri();
        return ResponseEntity.created(uri).body(newEvent);
    }
}
```

`EventDto` 앞에 `@Valid` 애노테이션을 붙이면 우리가 바로 전에 설정한 값들에 대해서 유효한지 검증합니다. 만약 검증에 실패하면 다음 파라미터로 넘긴 `Errors` 객체에 에러 정보가 들어가게 됩니다. 이제 테스트를 돌려보면 정상적으로 수행됨을 알 수 있습니다. 이제 로직 상 들어오면 안되는 값들일 경우를 살펴보도록 하겠습니다. 쉽게 생각해볼 수 있는 예외 상황은 다음과 같습니다.

* basePrice > maxPrice && maxPrice != 0
* beginEnrollmentDateTime > closeEnrollmentDateTime > beginEventDateTime > endEventDateTime 이 경우를 성립하지 않을 때.

테스트 코드를 작성해볼까요?

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class EventControllerTest {

    /* same */

    @Test
    public void 이벤트_생성_잘못된_입력_이상한_데이터_가진_객체가_들어올_때_BAD_REQUEST() throws Exception {


        EventDto eventDto = EventDto.builder()
                .name("Spring")
                .description("REST API Development with Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2019, 7, 23, 9, 0, 0))
                .closeEnrollmentDateTime(LocalDateTime.of(2019, 8, 1, 23, 59, 0))
                .beginEventDateTime(LocalDateTime.of(2019, 8, 6, 11, 0, 0))
                .endEventDateTime(LocalDateTime.of(2019, 8, 5, 14, 0, 0))
                .basePrice(10000)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .build();

        mockMvc.perform(
                post("/api/events")
                        .contentType(MediaType.APPLICATION_JSON_UTF8)
                        .accept(MediaTypes.HAL_JSON)
                        .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isBadRequest())
        ;
    }
}
```

자 역시 실패합니다. 이런 `JSR-330`은 이런 비지니스 로직에 대한 검증은 하지 못하기 때문이죠. 이럴 경우 데이터가 비지니스 로직에 잘 맞게 들어가는지 검증하는 `Validator`를 따로 만들어야 합니다. `EventValidator`를 만들고 다음을 입력해주세요.

src/main/java/project/events/EvnetValidator.java
```java
package com.gurumee.keesunrestapi.events;

import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;

import java.time.LocalDateTime;

@Component
public class EventValidator {
    public void validate(EventDto eventDto, Errors errors){
        if (eventDto.getBasePrice() > eventDto.getMaxPrice() && eventDto.getMaxPrice() != 0) {
            errors.rejectValue("basePrice","wrong value", "BasePrice is wrong");
            errors.rejectValue("maxPrice","wrong value", "MaxPrice is wrong");
        }

        LocalDateTime endEventDateTime = eventDto.getEndEventDateTime();
        LocalDateTime beginEventDateTime = eventDto.getBeginEventDateTime();
        LocalDateTime closeEnrollmentDateTime = eventDto.getCloseEnrollmentDateTime();
        LocalDateTime beginEnrollmentDateTime = eventDto.getBeginEnrollmentDateTime();

        if (endEventDateTime.isBefore(beginEventDateTime) ||
                endEventDateTime.isBefore(closeEnrollmentDateTime) ||
                endEventDateTime.isBefore(beginEnrollmentDateTime)
        ) {
            errors.rejectValue("endEventDateTime", "wrong value", "endEventDateTime is wrong");
        }

        if (beginEventDateTime.isBefore(closeEnrollmentDateTime) ||
                beginEventDateTime.isBefore(beginEnrollmentDateTime)
        ) {
            errors.rejectValue("beginEventDateTime", "wrong value", "beginEventDateTime is wrong");
        }

        if (closeEnrollmentDateTime.isBefore(beginEnrollmentDateTime) ) {
            errors.rejectValue("closeEnrollmentDateTime", "wrong value", "closeEnrollmentDateTime is wrong");
        }
    }
}
```

앞서 말한 검증 오류들에 코드들을 기술하였습니다. 이제 이 객체를 `EventController` 에서 사용하면 됩니다. 코드를 다음곽 같이 수정해주세요.

src/main/java/project/EventController.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    private final EventRepository eventRepository;
    private final ModelMapper modelMapper;
    private final EventValidator eventValidator;

    public EventController(EventRepository eventRepository, ModelMapper modelMapper, EventValidator eventValidator){
        this.modelMapper = modelMapper;
        this.eventRepository = eventRepository;
        this.eventValidator = eventValidator;
    }

    @PostMapping
    public ResponseEntity createEvent(@RequestBody @Valid EventDto eventDto, Errors errors) {

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().build();
        }

        eventValidator.validate(eventDto, errors);

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().build();
        }

        Event event = modelMapper.map(eventDto, Event.class);
        Event newEvent = eventRepository.save(event);
        URI uri = linkTo(EventController.class).slash(newEvent.getId()).toUri();
        return ResponseEntity.created(uri).body(newEvent);
    }
}
```

이제 테스트를 돌려보면 무사히 통과하는 것을 볼 수 있습니다.


## Bad Request 응답

자 이제 보다 클라이언트 친화적이 API가 되기 위해서 서버 에러가 났을 때 `Errors` 객체의 값들을 이용해서 메세지를 던져보도록 합시다. 먼저 `EventControllerTest` 를 다음과 같이 수정해주세요.

src/test/java/projcet/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

/* import */

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class EventControllerTest {

    /* same */

    @Test
    public void 이벤트_생성_잘못된_입력_이상한_데이터_가진_객체가_들어올_때_BAD_REQUEST() throws Exception {


        EventDto eventDto = EventDto.builder()
                .name("Spring")
                .description("REST API Development with Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2019, 7, 23, 9, 0, 0))
                .closeEnrollmentDateTime(LocalDateTime.of(2019, 8, 1, 23, 59, 0))
                .beginEventDateTime(LocalDateTime.of(2019, 8, 6, 11, 0, 0))
                .endEventDateTime(LocalDateTime.of(2019, 8, 5, 14, 0, 0))
                .basePrice(10000)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .build();

        mockMvc.perform(
                post("/api/events")
                        .contentType(MediaType.APPLICATION_JSON_UTF8)
                        .accept(MediaTypes.HAL_JSON)
                        .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(jsonPath("$[0].objectName").exists())
        .andExpect(jsonPath("$[0].defaultMessage").exists())
        .andExpect(jsonPath("$[0].code").exists())
        .andExpect(status().isBadRequest())
        ;
    }
}
```

밑에 `andExpect` 에서 `spEL` 구문을 활용해 만약 던져진 데이터가 배열일 시 첫 번째 에러 데이터의 objectName, defaultMessage, code 정보가 있는지 확인하는 테스트입니다. 테스트를 돌려보면 역시 실패합니다. 왜냐하면 우리는 에러 정보를 보내준 적이 없으니까요. 이제 `EventController`를 다음과 같이 수정해주세요.

src/main/java/project/events/EventController
```java
package com.gurumee.keesunrestapi.events;

/* import */

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {

    /* same */

    @PostMapping
    public ResponseEntity createEvent(@RequestBody @Valid EventDto eventDto, Errors errors) {

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().body(errors);
        }

        eventValidator.validate(eventDto, errors);

        if (errors.hasErrors()){
            return ResponseEntity.badRequest().body(errors);
        }

        Event event = modelMapper.map(eventDto, Event.class);
        Event newEvent = eventRepository.save(event);
        URI uri = linkTo(EventController.class).slash(newEvent.getId()).toUri();
        return ResponseEntity.created(uri).body(newEvent);
    }
}
```

그냥 단순하게 응답 body 에 errors 객체를 넘겨주었습니다. 과연 이 방법으로 테스트가 통과할까요? 결과는 실패합니다. 왜냐하면 `Errors` 클래스는 자바 빈 스펙을 준수하는 클래스가 아니기 때문에 Json 직력화 단계에서 실패하기 때문입니다. 이 경우 우리가 해당 Serializer 클래스를 구현해야 합니다. `commons` 디렉토리를 만들고 `ErrorSerializer`를 다음과 같이 만들어주세요.

src/main/java/project/commons/ErrorsSerializer.java
```java
package com.gurumee.keesunrestapi.commons;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import org.springframework.boot.jackson.JsonComponent;
import org.springframework.validation.Errors;

import java.io.IOException;

@JsonComponent
public class ErrosSerializer extends JsonSerializer<Errors> {
    @Override
    public void serialize(Errors errors, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartArray();
        errors.getFieldErrors().stream().forEach( e -> {
                try{
                    jsonGenerator.writeStartObject();
                    jsonGenerator.writeStringField("field", e.getField());
                    jsonGenerator.writeStringField("objectName", e.getObjectName());
                    jsonGenerator.writeStringField("code", e.getCode());
                    jsonGenerator.writeStringField("defaultMessage", e.getDefaultMessage());
                    Object rejectedValue = e.getRejectedValue();
                    if (rejectedValue != null) {
                        jsonGenerator.writeStringField("rejectedValue", rejectedValue.toString());
                    }
                    jsonGenerator.writeEndObject();
                } catch (IOException ioe) {

                }
            }
        );

        errors.getGlobalErrors().forEach( e -> {
                try{
                    jsonGenerator.writeStartObject();
                    jsonGenerator.writeStringField("objectName", e.getObjectName());
                    jsonGenerator.writeStringField("code", e.getCode());
                    jsonGenerator.writeStringField("defaultMessage", e.getDefaultMessage());
                    jsonGenerator.writeEndObject();
                } catch (IOException ioe) {

                }
            }
        );

        jsonGenerator.writeEndArray();
    }
}
```

해당 필드 에러들, 글로벌 에러들에 대해서 프로퍼티들을 뽑아서 JSON으로 만들어주었습니다. 그리고 `@JsonComponent` 애노테이션을 붙이면 우리가 별도 코드를 붙이지 않아도 `Errors` 클래스를 직렬화할 때 `ObjectMapper`가 알아서 쓰게 됩니다. 실제 테스트를 돌려보면 무사히 톧과하는 것을 볼 수 있습니다.


## 비지니스 로직 적용

## 매개 변수를 이용한 테스트
