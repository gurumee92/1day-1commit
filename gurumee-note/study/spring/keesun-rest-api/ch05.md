REST API 보안 적용
===================

> 백기선님의 인프런 강좌 "스프링 기반 REST API 개발"을 보고 정리한 문서들입니다. 강의는 개발자의 피와 땀의 결실이라고 생각합니다. 꼭 인프런 강의를 듣고, 참고 사항으로 보셨으면 좋겠습니다.

Contents
--------------

1. Account 도메인 추가
2. 스프링 시큐리티 적용
3. 스프링 시큐리티 기본 설정
4. 스프링 시큐리티 폼 인증 설정
5. 스프링 시큐리티 OAuth2 인증 서버 설정
6. 리소스 서버 설정
7. 문자열을 외부 설정으로 빼내기
8. 이벤트 API 점검
9. 현재 사용자 조회
10. 출력 값 제한하기
11. 깨진 테스트 살펴보기

* [소스코드](https://github.com/gurumee92/keesun-rest-api) 브랜치: ENH-05


## Account 도메인 추가

이번 절에서는 스프링 시큐리티 적용을 위하여 `Account`, `AccountRoles`를 만들고 `Event`에 `Account`를 다대일 매핑하겠습니다. 별로 설명할 내용은 없으니 코드를 살펴보시죠.

src/main/java/project/accounts/Account.java
```java
package com.gurumee.keesunrestapi.accounts;

import lombok.*;

import javax.persistence.*;
import java.util.Set;

@NoArgsConstructor @AllArgsConstructor
@EqualsAndHashCode(of="id")
@Getter @Setter
@Builder
@Entity
public class Account {
    @Id
    @GeneratedValue
    private Integer id;

    private String email;

    private String password;

    //컬렉션이니 컬렉션 매핑
    @ElementCollection(fetch = FetchType.EAGER)
    @Enumerated(EnumType.STRING)
    private Set<AccountRole> roles;
}
```

src/main/java/project/accounts/AccountRole.java
```java
package com.gurumee.keesunrestapi.accounts;

public enum AccountRole {
    ADMIN, USER
}
```

src/main/java/project/events/Event.java
```java
package com.gurumee.keesunrestapi.events;

import com.gurumee.keesunrestapi.accounts.Account;

/* import */

@Builder @AllArgsConstructor @NoArgsConstructor
@Getter @Setter @ToString @EqualsAndHashCode(of="id")
@Entity
public class Event {
    /* 이전과 동일 */

    @ManyToOne
    private Account manager;

    /* 이전과 동일 */
}
```


## 스프링 시큐리티 적용

이번 절에서는 간단하게 **스프링 시큐리티**를 알아보고, 적용해보도록 하겠습니다. 스프링 시큐리티는 이름 그대로 보안 코드와 관련된 스프링 프로젝트입니다. 대표적으로 2개의 기능이 있는데 다음과 같습니다.

1. 웹 필터 레벨에서의 보안 (FilterSecurityInterceptor)
2. 메소드 레벨에서의 보안 (MethodSecurityInterceptor)

두 개다 `SecurityInterceptor` 하위 인터페이스들입니다. 일반적으로 로그인 시 일어나는 흐름은 다음과 같습니다.

1. 웹 상에서 사용자 요청 (로그인 같은)
2. WebServeletFilter -> SecurityInterceptor
3. SecurityInterceptor -> SecurityContextHolder 인가 받은 유저인지 확인, 인가 받은 애면 클라이언트로, 아니라면 4번으로 흐름이 이동합니다.
4. SecurityContextHoler -> SecurityInterceptor
5. SecurityInterceptor -> AuthenticationManager(UserDetailsService) 로그인 가능 여부를 판단합니다. 
6. AuthenticationManager -> SecurityInterceptor 
    1. 로그인 실패 시, 클라이언트에게 넘어갑니다.
    2. 로그인 성공 시, SecurityContextHolder 에 해당 유저 정보를 넣습니다.
7. SecurityInterceptor -> AccessDecisionManager 인가 정보를 가져옵니다.
8. AccessDecisionManager -> SecurityInterceptor -> Client

이제 스프링 시큐리티를 적용하겠습니다. `pom.xml`에 다음 의존성을 추가해주세요.

pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<!-- 이전과 동일 -->
	<dependencies>
		<!-- 이전과 동일 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.security.oauth.boot</groupId>
			<artifactId>spring-security-oauth2-autoconfigure</artifactId>
			<version>2.1.6.RELEASE</version>
		</dependency>
		<!-- 이전과 동일 -->
	</dependencies>

	<!-- 이전과 동일 -->
</project>
```

이제 AccountService를 테스트할 것입니다. 우리의 테스트 시나리오는 다음과 같습니다.

1. 적절한 이름으로 계정을 찾을 경우, 우리가 만든 이름, 비밀번호와 꺼내온 유저 정보와 일치해야 합니다.
2. 적절치 않은 이름으로 계정을 찾을 경우 UsernameNotFoundException 이 발생해야 합니다.

다음은 위 테스트 계획들을 코드로 표현한 것입니다.

src/test/java/project/accounts/AccountServiceTest.java
```java
package com.gurumee.keesunrestapi.accounts;

import org.hamcrest.Matchers;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.Collection;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("test")
public class AccountServiceTest {

    @Rule
    public ExpectedException expectedException = ExpectedException.none();

    @Autowired
    private AccountRepository accountRepository;

    @Autowired
    private AccountService accountService;

    @Test
    public void 유저_이름으로_계정_불러오기() {
        String email = "gurumee@naver.com";
        String password = "guruemee";

        Account account = Account.builder()
                .email(email)
                .password(password)
                .roles(Set.of(AccountRole.USER))
                .build();
        accountRepository.save(account);

        UserDetailsService userDetailsService = accountService;
        UserDetails userDetails = userDetailsService.loadUserByUsername(email);

        Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
        System.out.println(authorities);
        assertThat(userDetails.getUsername()).isEqualTo(email);
        assertThat(userDetails.getPassword()).isEqualTo(password);
    }

    @Test
    public void 유저_이름으로_계정_불러오기_실패(){
        final String username = "random@naver.com";

        expectedException.expect(UsernameNotFoundException.class);
        expectedException.expectMessage(Matchers.containsString(username));

        accountService.loadUserByUsername(username);
    }
}
```

이제 테스트를 통과하기 위해서 AccountRepository, AccountService를 구현하도록 하겠습니다.

src/main/java/project/accounts/AccountRepository.java
```java
package com.gurumee.keesunrestapi.accounts;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {

    Optional<Account> findByEmail(String email);
}
```

src/main/java/project/accounts/AccountService.java
```java
package com.gurumee.keesunrestapi.accounts;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class AccountService implements UserDetailsService {
    private AccountRepository accountRepository;

    @Autowired
    public AccountService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Account account = accountRepository.findByEmail(username)
                .orElseThrow( () -> new UsernameNotFoundException(username) );

        return new User(account.getEmail(), account.getPassword(), authorities(account.getRoles()));
    }

    private Collection<? extends GrantedAuthority> authorities(Set<AccountRole> roles) {

        return roles.stream()
                .map( r ->  new SimpleGrantedAuthority("ROLE_" + r.name()))
                .collect(Collectors.toSet());
    }
}
```

이제 테스트를 구동시켜보면 문제 없이 통과되는 것을 확인할 수 있습니다. 여기서 알 수 있는 것은 `UserDetails`는 스프링 클래스인 `User` 클래스로 만들 수 있으며, 이 클래스는 username, password, authorities 정보를 주어서 생성할 수 있습니다. 다만 권한 정보를 줄 때 접두사로 "ROLE_" 을 붙여 주어야 한다는 것을 알아야 합니다.   


## 스프링 시큐리티 기본 설정

이번 절에서는 서버에 스프링 시큐리티 기본 설정을 적용해보도록 하겠습니다. 먼저 `Application`에 있는 `ModelMapper` 빈을 `AppConfig`라는 Configuration Bean 을 만들어 관리하도록 하겠습니다. 그리고 스프링 시큐리티를 적용할 수 있도록 `PasswordEncoder` 빈을 만들겠습니다. `configs/AppConfig`를 만들어주세요.

src/main/java/project/configs/AppConfig.java
```java
package com.gurumee.keesunrestapi.configs;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class AppConifg {
    // Application.java 에서 등록해줬던 빈. Application 해당 코드는 제거해주세요.
    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }

    // 비밀번호 인코딩을 설정하는 빈입니다.
    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```

이제 스프링 시큐리티를 적용하도록 하겠습니다. 우선 우리의 계획은 이렇습니다.

* /docs/index.html, 정적 파일에는 스프링 시큐리티를 적용하지 않습니다.
* GET 요청에 대해서는 모두 허용합니다.
* 그 외 모든 요청에 대해서는 인가된 사용자에게만 허용합니다.

이 중 정적 파일에 대해서 무시하는 설정만 하도록 하겠습니다. `configs/SecurityConfig` 파일을 만들어 주세요.

src/main/java/project/configs/SecurityConfig.java
```java
package com.gurumee.keesunrestapi.configs;

import com.gurumee.keesunrestapi.accounts.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // 인가 정보를 확인하기 위한 빈입니다.
    @Autowired
    private AccountService accountService;

    // 비밀번호 인코딩을 위한 빈입니다.
    @Autowired
    private PasswordEncoder passwordEncoder;

    // 토큰을 저장하는 객체입니다. 인메모리-토큰 스토어 방식입니다.
    @Bean
    public TokenStore tokenStore() {
        return new InMemoryTokenStore();
    }

    // 스프링 시큐리티 적용을 위해서 해당 메소드를 오버라이드 후 빈으로 등록해주어야 합니다.
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    // 위의 AuthenticationManager를 설정하는 메소드입니다.
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(accountService)
                .passwordEncoder(passwordEncoder);
    }

    // web filter에서 해당 url 들에 대해서 스프링 시큐리티 적용을 무시합니다.
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/docs/index.html");
        web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

//    // 스프링 시큐리티 내에서 해당 url에 대해서 모든 유저에게 접근을 허용합니다.
//    @Override
//    protected void configure(HttpSecurity http) throws Exception {
//        http.authorizeRequests()
//                .mvcMatchers("/docs/index.html").permitAll()
//                .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();
//    }
}
```

주석에 간략한 설명을 적어 두었습니다. 읽어보시면 코드를 이해할 수 있을 겁니다. 이렇게 해서 설정이 끝났습니다. 실제로 이제 서버에 요청을 해보면 우리가 만든 API로 접근하면 로그인을 하라고 페이지가 뜹니다. 하지만 /docs/index.html은 바로 접속하는 것을 확인할 수 있습니다.


## 스프링 시큐리티 폼 인증 설정

이번에는 스프링 시큐리티 폼 인증 설정을 하겠습니다. 먼저 저번 절에 주설처리 했던 `SecurityConfig`의 configure 메소드의 주석을 풀고 다음처럼 수정해주세요.

src/main/java/project/configs/SercurityConfig.java
```java
package com.gurumee.keesunrestapi.configs;

/* 임포트 구문 */ 

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    /* 이전과 동일 */

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.anonymous()            // 익명 사용자 허용
                    .and()
                .formLogin()        // 로그인 폼 사용
                    .and()
                .authorizeRequests()
                .mvcMatchers(HttpMethod.GET, "/api/**").permitAll() //GET 요청에 대해서 허용한다.
                .anyRequest().authenticated() // 나머지는 로그인이 필요하다.
        ;
    }
}
```

그 후 비밀번호를 매칭시키기 위해서 `AccountService`에서 비밀번호 인코딩 로직을 추가하는 `saveAccount` 메소드를 만들겠습니다.

src/main/java/project/accounts/AccountService.java
```java
package com.gurumee.keesunrestapi.accounts;

/* import */

@Service
public class AccountService implements UserDetailsService {
    private AccountRepository accountRepository;
    // 추가 코드
    private PasswordEncoder passwordEncoder;

    @Autowired
    public AccountService(AccountRepository accountRepository, PasswordEncoder passwordEncoder) {
        this.accountRepository = accountRepository;
        // 추가 코드
        this.passwordEncoder = passwordEncoder;
    }

    // 추가 코드
    public Account saveAccount(Account account){
        //패스워드 인코딩을 이용해서 비밀번호 저장 시 인코딩합니다.
        account.setPassword(this.passwordEncoder.encode(account.getPassword()));
        //인코딩 된 비밀번호를 가진 계정을 저장합니다.
        return this.accountRepository.save(account);
    }

    /* 이전과 동일 */
}
```

이제 적용이 잘 됐는지 테스트 코드를 수정해서 테스트해보도록 하겠습니다.

src/test/java/project/accounts/AccountServiceTest.java
```java
package com.gurumee.keesunrestapi.accounts;

/*import */

@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("test")
public class AccountServiceTest {
    
    /* sane code */

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Test
    public void 유저_이름으로_계정_불러오기() {
        String email = "gurumee@naver.com";
        String password = "guruemee";

        Account account = Account.builder()
                .email(email)
                .password(password)
                .roles(Set.of(AccountRole.USER))
                .build();
        // 아래 코드는 레포지코리에서 서비스계층을 이용하는 코드로 변경되었습니다.
        accountService.saveAccount(account);

        UserDetailsService userDetailsService = accountService;
        UserDetails userDetails = userDetailsService.loadUserByUsername(email);

        Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
        System.out.println(authorities);
        assertThat(userDetails.getUsername()).isEqualTo(email);
        //저장된 비밀번호가 인코딩 되어있는지 테스트합니다.
        assertThat(this.passwordEncoder.matches(password, userDetails.getPassword())).isTrue();
    }

    /* same cod */
}
```

이제 테스트를 구동해보면, 무사히 성공하는 것을 알 수 있습니다. 다음 절을 위해서 우리는 앱이 구동될 때, 계정을 하나 만들도록 `ApplicationRunner`를 하나 등록하겠습니다. `AppConifg`를 다음처럼 수정해주세요.

src/main/java/project/configs/AppConfig.java
```java
package com.gurumee.keesunrestapi.configs;

/* import */

@Configuration
public class AppConifg {
    /* same code */

    @Bean
    public ApplicationRunner applicationRunner(){
        return new ApplicationRunner() {
            @Autowired
            private AccountService accountService;

            @Override
            public void run(ApplicationArguments args) throws Exception {
                Account keesun = Account.builder()
                        .email("keesun@email.com")
                        .password("keesun")
                        .roles(Set.of(AccountRole.USER, AccountRole.ADMIN))
                        .build();
                accountService.saveAccount(keesun);
            }
        };
    }
}
```

## 스프링 시큐리티 OAuth2 인증 서버 설정

이번에는 스프링 시큐리티 OAuth2 인증 서버를 설정해보겠습니다. 먼저 `pom.xml`에 시큐리티 테스트 의존성을 추가해주세요.

pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<!-- same code  -->
    <dependencies>
        <!-- same code  -->
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<!-- same code -->
</project>
```

테스트 코드를 작성하기에 앞서 먼저 우리는 OAuth 2.0 프레임워크를 통해 클라이언트에게 Acceess Token 을 제공하기 위해 다음의 인증 및 권한의 위임 방법, 'grant_type' 2가지를 사용할 것임을 밝힙니다.

1. Password
2. Refresh Token

    참고! 
    Password 인증 방식은 절대로 3rd 파티 앱들에게 제공하면 안됩니다. 보통의 인증 방식의 경우 여러번의 홉을 거치나 이 방식은 딱 한 번의 홉으로 우리 서버가 저장하고 있는 유저 정보를 직접적으로 접근하는 방식입니다. 따라서 회사가 관리하는 서비스들에게만 허용하는 것을 권장합니다.

이제 테스트 코드를 작성해볼까요? 우리가 테스트 할 사항은 다음과 같습니다. 

1. 적당한 email, passowrd, roles를 가진 Account를 저장합니다.
2. 적당한 clientId, clientSecret 값을 저장합니다.
3. POST /oauth/token에 다음의 정보를 가지고 토큰을 요청합니다.
    - Authorization: Basic (clientId, clientSecret)
    - Params : { "username": email, "password":password, "grant_type": "password" }
4. 이 요청에 대한 응답으로 다음 조건이 충족되야 합니다.
    - status = 201
    - token_type = bearer
    - refresh_token exist
    - expires_in exist
    - scope = "read write"   

이제 코드를 작성해봅시다. 테스트 디렉토리에 configs라는 디렉토리를 만들고 `AuthServerConfigTest`를 다음처럼 만들어주세요.

src/test/java/project/configs/AuthServerConfig.java
```java
package com.gurumee.keesunrestapi.configs;

import com.gurumee.keesunrestapi.accounts.Account;
import com.gurumee.keesunrestapi.accounts.AccountRole;
import com.gurumee.keesunrestapi.accounts.AccountService;
import com.gurumee.keesunrestapi.commons.BaseControllerTest;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.httpBasic;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

public class AuthServerConfigTest extends BaseControllerTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void 인증_토큰을_발급_받는_테스트() throws Exception{
        /*
         * 우리가 제공할 Grant-Type 은 다음과 같습니다.
         * 1. Password - 3rd party must not allowed only our apps
         * 2. Refresh
         */
         //given
        final String email = "gurumee92@email.com";
        final String password = "gurumee";
        final Account account = Account.builder()
                .email(email)
                .password(password)
                .roles(Set.of(AccountRole.USER, AccountRole.ADMIN))
                .build();
        this.accountService.saveAccount(account);

        assertThat(password).isEqualTo(account.getPassword());

        final String clientId = "myApp";
        final String clientSecret = "pass";

        //then
        this.mockMvc.perform(
                post("/oauth/token")
                    .with(httpBasic(clientId, clientSecret))
                    .param("username", email)
                    .param("password", password)
                    .param("grant_type", "password")
        )
        //when
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(jsonPath("access_token").exists())
        .andExpect(jsonPath("token_type").value("bearer"))
        .andExpect(jsonPath("refresh_token").isNotEmpty())
        .andExpect(jsonPath("expires_in").isNumber())
        .andExpect(jsonPath("scope").value("read write"))
                ;
    }
}
```

당연히 우리는 `AuthServerConifg`를 만들지 않았기 때문에 이 테스트는 실패합니다. 코드를  작성하도록 하겠습니다.

src/main/java/project/configs/AuthServerConfig.java
```java
package com.gurumee.keesunrestapi.configs;

import com.gurumee.keesunrestapi.accounts.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.TokenStore;

@Configuration
@EnableAuthorizationServer
public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private AccountService accountService;

    @Autowired
    private TokenStore tokenStore;

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.passwordEncoder(passwordEncoder);
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        final String clientId = "myApp";
        final String clientSecret = "pass";

        clients.inMemory()
            .withClient(clientId)
            .authorizedGrantTypes("password", "refresh_token")
            .scopes("read", "write")
            .secret(this.passwordEncoder.encode(clientSecret))
            .accessTokenValiditySeconds(10 * 60)
            .refreshTokenValiditySeconds(6 * 10 * 60)
        ;
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(authenticationManager)
            .userDetailsService(accountService)
            .tokenStore(tokenStore)
                ;
    }
}
```

OAuth 인증 서버로 설정하기 위해서 다음의 작업이 필요합니다. (다음 작업들은 위의 코드들을 부분 부분 설명한 것입니다.)

1. Config 파일에 @Configuration, @EnableAuthorizationServer 애노테이션들을 명시해주어야 합니다.
2. 그 후 `EnableAuthorizationServer`상속 받고 3가지 `configure` 메소드를 오버라이딩 합니다.
3. `AuthorizationServerSecurityConfigurer` 파라미터를 가진 configure 메소드에서 우리가 빈으로 등록한 PasswordEncoder를 설정해줍니다.
4. `ClientDetailsServiceConfigurer` 파라미터를 가진 configure 메소드에서 다음의 정보들을 등록합니다.
    - 저장 방식 : In Memory
    - 클라이언트 ID
    - 인증 방식 : ['password', 'refresh_token']
    - 스코프: ["read", "write"]
    - 클라이언트 시크릿 (이때 시크릿 정보를 인코딩해서 넘겨주어야 합니다.)
    - AccessToken 유효 시간 
    - RefreshToken 유효 시간
5. `AuthorizationServerEndpointsConfigurer` 파라미터를 가진 configure 메소드에서, 우리가 빈으로 등록한 `AuthenticationManager`, `AccountService`, `TokenStore`를 설정해줍니다.

이제 테스트를 돌려볼까요? 성공합니다! 이렇게 해서 우리 API 서버를 OAuth2 인증 서버로 설정하였습니다.


## 리소스 서버 설정

이번엔 리소스 서버를 설정해보도록 하겠습니다. 리소스 서버는 OAuth2 인증 서버에 인가된 유저에 한해서, 가지고 있는 데이터를 허용해주는 서버입니다. 이 때, HTTP 요청에 대해서 세밀하게 핸들링할 수 있습니다. 바로 코드를 작성하도록 하죠. 메인 configs 디렉토리에 `ResourceServerConfig` 클래스를 생성하고 다음 코드를 넣어주세요.

src/main/java/project/configs/ResourceServerConfig.java
```java
package com.gurumee.keesunrestapi.configs;

import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.error.OAuth2AccessDeniedHandler;

/** 리소스 서버 설정
 * 인증 서버와 리소스 서버는 따로 분리하는게 일반적입니다
 */
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {

    /**
     * resource ID를 설정하는 메소드입니다. ID는 무조건 변경해주어야 합니다.
     * @param resources
     * @throws Exception
     */
    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
        resources.resourceId("event");
    }

    /**
     * oauth2 인증에 대해서 HTTP 요청을 핸들링합니다.
     * @param http
     * @throws Exception
     */
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.anonymous()
                .and()
            .authorizeRequests()
                .mvcMatchers(HttpMethod.GET, "/api/**")
                    .permitAll()
                .anyRequest()
                    .authenticated()
                .and()
            .exceptionHandling()
                .accessDeniedHandler(new OAuth2AccessDeniedHandler())
                ;
    }
}
```

리소스 서버 설정 파일을 만드는 과정은 다음과 같습니다.

1. @Configuration, @EnabledResourceServer 애노테이션을 붙여 Configuration Bean을 만듭니다.
2. ResourceServerConfigurerAdapter를 상속하고 2개의 configure 메소드를 오버라이딩 합니다.
3. ResourceServerSecurityConfigurer 파라미터를 가진 configure에서 꼭 resourceId를 변경해줍니다. 그 외, 토큰 스토어, 인증 매니저, 접근 시 거부할 때 처리 등을 처리할 수 있습니다.
4. HttpSecurity 파라미터를 가진 configure에서 HTTP 요청에 대해서 핸들링합니다. 익명의 사용자, 인가된 사용자를 구분지어 처리하고 어떤 HTTP 메소드와 URL 경로에 따라 모두 허용할지, 인가된 유저만 허용할지, 거부할지 핸들링할 수 있습니다.

    참고! 
    일반적으로, 리소스 서버와 OAuth2 서버는 다른 서버로 구성합니다. 하지만 이 프로젝트는 그것을 다루지는 않습니다.

우리는 /api/ 하위 URL에 대해서 GET은 모두 허용, 그외 요청에 대해서는 인가된 유저만 허용하도록 만들어두었습니다. 이제 깨졌던 이벤트 테스드들을 모두 복구하겠습니다. 먼저 `EventControllerTest` 파일 내부에 `AuthServerConfigTest`에서 토큰을 받아오는 부분을 빼온 후 다음 메소드를 만들어주세요.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

// import

public class EventControllerTest extends BaseControllerTest {

    //same code

    //getAccessToken을 위한 AccountService 의존성 주입
    @Autowired
    private AccountService accountService;

    //same code

    //Authorization "Bearer { AccessToken }" 을 보다 쉽게 하기 위한 메소드
    private String getBearerToken() throws Exception {
        return "Bearer " + getAccessToken();
    }

    //AccessToken을 받아오는 메소드
    private String getAccessToken() throws Exception {
        final String email = "gurumee92@email.com";
        final String password = "gurumee";
        final Account account = Account.builder()
                .email(email)
                .password(password)
                .roles(Set.of(AccountRole.USER, AccountRole.ADMIN))
                .build();
        this.accountService.saveAccount(account);

        final String clientId = "myApp";
        final String clientSecret = "pass";
        ResultActions perform = this.mockMvc.perform(
                post("/oauth/token")
                        .with(httpBasic(clientId, clientSecret))
                        .param("username", account.getEmail())
                        .param("password", account.getPassword())
                        .param("grant_type", "password")
        );
        MockHttpServletResponse response = perform.andReturn().getResponse();
        String responseBody = response.getContentAsString();
        Jackson2JsonParser parser = new Jackson2JsonParser();
        return parser.parseMap(responseBody).get("access_token").toString();
    }
}
```

그 후 get 요청을 하는 테스트를 제외하고 모든 메소드에 mockMvc.perform( HTTPMETHOD(URL).header(HttpHeaders.AUTHORIZATION, getBearerToken())... ) 을 넣으면 됩니다. 예를 들어 존재하지_않는_이벤트_수정_IsNotFound 메소드를 한 번 살펴보도록 하죠.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

// import

public class EventControllerTest extends BaseControllerTest {

    //same code

    @Test
    public void 존재하지_않는_이벤트_수정_실패_IsNotFound() throws Exception {
        Event event = this.generateEvent(300);
        EventDto eventDto = this.modelMapper.map(event, EventDto.class);

        mockMvc.perform(
                put("/api/events/12345")
                        //이 부분이 수정된 코드입니다. 인가된 토큰을 헤더에 넣어줍니다.
                        .header(HttpHeaders.AUTHORIZATION, getBearerToken())

                        .contentType(MediaType.APPLICATION_JSON_UTF8)
                        .content(objectMapper.writeValueAsString(eventDto))
        )
                .andDo(print())
                .andExpect(status().isNotFound())
        ;
    }

    //same code
}
```

수정된 부분이 잘 보이시나요? 이렇게 모든 요청 아래 header 메소드를 넣어주시면 됩니다. 먼저 단일 테스트를 진행해보면 잘 동작하는 것을 알 수 있습니다. 근데 모든 테스트를 동작시키면 테스트가 깨집니다. NullPointerException이 발생합니다. 왜 그럴까요? 에러 메세지 위의 요청 부분을 잘 살펴보면, `MockHttpServletResponse` 밑에 `Body` 부분을 살펴보면, 에러에 대한 메시지가 나옵니다. 잘 읽어보면, `"error_description":"query did not return a unique result: 6` 형식의 메세지가 보입니다. 

위 메세지를 직역하면 쿼리가 유니크 하지 않다는건데, 이는 계속해서 같은 계정을 반복적으로 만들기 때문입니다. 모든 테스트를 구동할 때마다, `getAccessToken` 메소드에 의해서 우리는 한 계정을 계속 만들게 됩니다. 그래서 이런 문제가 생기는 것이죠. 제일 쉽게 해결하는 방법은 @Before, @After 애노테이션을 붙인 후, setUp, tearDown 등의 메소드를 만드는 것입니다. 코드를 고쳐보도록 하죠.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

// import

public class EventControllerTest extends BaseControllerTest {

    //same code

    @Autowired
    private AccountRepository accountRepository;

    @Before
    public void setUp() {
        //테스트가 구동 전에 모든 데이터를 삭제합니다.
        eventRepository.deleteAll();
        accountRepository.deleteAll();
    }

    //same code
}
```

이렇게 해두면 테스트 메소드가 구동될 때마다 모든 데이터를 삭제하게 됩니다. 이제 테스트를 돌려볼까요? 이런... 그래도 이벤트_생성_정상_입력_OK 메소드가 깨지네요. 왜 그럴까요? 에러 메세지를 살펴봅시다.

```
org.springframework.restdocs.snippet.SnippetException: The following parts of the payload were not documented:
{
  "manager" : null
}
```

이는 유저에 대해서 문서화 작업을 하지 않았기 때문입니다. 이것을 해결하려면 `Account` 정보에 대해서 문서화를 진행하면 됩니다. 하지만! 우리는 귀찮기 때문에 다른 방법을 통해서 넘어가죠. responseFields 를 relaxedResponseFields로 바꿔주세요 이렇게 말이죠.

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

// import

public class EventControllerTest extends BaseControllerTest {

    //same code

    @Test
    public void 이벤트_생성_정상_입력_OK() throws Exception {

        EventDto eventDto = EventDto.builder()
                .name("Spring")
                .description("REST API Development with Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2019, 7, 23, 9, 0, 0))
                .closeEnrollmentDateTime(LocalDateTime.of(2019, 8, 1, 23, 59, 0))
                .beginEventDateTime(LocalDateTime.of(2019, 8, 5, 11, 0, 0))
                .endEventDateTime(LocalDateTime.of(2019, 8, 5, 14, 0, 0))
                .basePrice(100)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .build();

        mockMvc.perform(
                post("/api/events")
                    .header(HttpHeaders.AUTHORIZATION, getBearerToken())
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .accept(MediaTypes.HAL_JSON)
                    .content(objectMapper.writeValueAsString(eventDto))
        )
        .andDo(print())
        .andExpect(status().isCreated())
        .andExpect(jsonPath("id").exists())
        .andExpect(header().exists(HttpHeaders.LOCATION))
        .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_UTF8_VALUE))
        .andExpect(jsonPath("free").value(false))
        .andExpect(jsonPath("offline").value(true))
        .andExpect(jsonPath("eventStatus").value(EventStatus.DRAFT.name()))
        .andExpect(jsonPath("_links.self").exists())
//                .andExpect(jsonPath("_links.profile").exists())
        .andExpect(jsonPath("_links.query-events").exists())
        .andExpect(jsonPath("_links.update-event").exists())
        .andDo(document("create-event",
                links(
                        linkWithRel("self").description("link to self"),
                        linkWithRel("query-events").description("link to query events"),
                        linkWithRel("update-event").description("link to update event"),
                        linkWithRel("profile").description("link to profile")
                ),
                requestHeaders(
                        headerWithName(HttpHeaders.ACCEPT).description("request header accept"),
                        headerWithName(HttpHeaders.CONTENT_TYPE).description("request header content type")
                ),
                requestFields(
                        fieldWithPath("name").description("Name of new event: String"),
                        fieldWithPath("description").description("Description of new event: String"),
                        fieldWithPath("beginEnrollmentDateTime").description("Begin Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("closeEnrollmentDateTime").description("End Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("beginEventDateTime").description("Begin DateTime of new event: DateTime"),
                        fieldWithPath("endEventDateTime").description("End DateTime of new event: DateTime"),
                        fieldWithPath("location").description("Location of new event: String"),
                        fieldWithPath("basePrice").description("Base Price of new event: Int"),
                        fieldWithPath("maxPrice").description("Max Price of new event: Int"),
                        fieldWithPath("limitOfEnrollment").description("Limit Of Enrollment of new event: Int")
                ),
                responseHeaders(
                        headerWithName(HttpHeaders.LOCATION).description("response header location"),
                        headerWithName(HttpHeaders.CONTENT_TYPE).description("response header content type")
                ),
                //이 부분이 바뀐 코드입니다. responseFields -> relaxedResponseFields
                relaxedResponseFields(
                        fieldWithPath("id").description("Id of new event: Int"),
                        fieldWithPath("name").description("Name of new event: String"),
                        fieldWithPath("description").description("Description of new event: String"),
                        fieldWithPath("beginEnrollmentDateTime").description("Begin Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("closeEnrollmentDateTime").description("End Enrollment DateTime of new event: DateTime"),
                        fieldWithPath("beginEventDateTime").description("Begin DateTime of new event: DateTime"),
                        fieldWithPath("endEventDateTime").description("End DateTime of new event: DateTime"),
                        fieldWithPath("location").description("Location of new event: String"),
                        fieldWithPath("basePrice").description("Base Price of new event: Int"),
                        fieldWithPath("maxPrice").description("Max Price of new event: Int"),
                        fieldWithPath("limitOfEnrollment").description("Limit Of Enrollment of new event: Int"),
                        fieldWithPath("offline").description("Is Offline of new event: boolean"),
                        fieldWithPath("free").description("Is Free Of Enrollment of new event: Int"),
                        fieldWithPath("eventStatus").description("Event Status Of Enrollment of new event: String"),
                        fieldWithPath("_links.self.href").description("Self URL of new event: url"),
                        fieldWithPath("_links.query-events.href").description("Query Events URL Enrollment of new event: url"),
                        fieldWithPath("_links.update-event.href").description("Update Event Of Enrollment of new event: url"),
                        fieldWithPath("_links.profile.href").description("Profile of new event: url")
                )
        ))
        ;
    }

    //same code
}
```

자 이제 모든 테스트가 통과합니다!


## 문자열을 외부 설정으로 빼내기

이번에는 하드 코딩된 문자열들을 외부 설정으로 빼네보겠습니다. 그 전에 잠깐 `Account`를 수정하겠습니다.

src/main/java/project/accounts/Account.java
```java
package com.gurumee.keesunrestapi.accounts;

// import

@NoArgsConstructor @AllArgsConstructor
@EqualsAndHashCode(of="id")
@Getter @Setter
@Builder
@Entity
public class Account {
    @Id
    @GeneratedValue
    private Integer id;

    // @Column 부분을 추가하였습니다.
    @Column(unique = true)
    private String email;

    private String password;

    @ElementCollection(fetch = FetchType.EAGER)
    @Enumerated(EnumType.STRING)
    private Set<AccountRole> roles;
}
```

email 필드가 고유할 수 있도록 @Column(unique=true) 애노테이션을 설정해 주었습니다. 이제 본격적으로 외부 파일을 이용해서 설정을 빼보도록 하겠습니다. 먼저 pom.xml에 다음을 추가해주세요.

pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- same code -->
	<dependencies>
		<!-- same code -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
			<optional>true</optional>
		</dependency>
        <!-- same code -->
	</dependencies>

	<!-- same code -->
</project>
```

이것은 외부 파일로 빼낼 때, 설정 파일에 따라 application.properties에 자동 완성을 가능하게 만들어줍니다.(Community 버전은 적용되지 않습니다.) 이제 coomons 디렉토리에 `AppProperties`를 생성하고 다음 코드를 넣어주세요.

src/main/java/project/commons/AppProperties.java
```java
package com.gurumee.keesunrestapi.commons;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import javax.validation.constraints.NotEmpty;

@Component
@ConfigurationProperties(prefix = "my-app")
@Getter @Setter
public class AppProperties {

    @NotEmpty
    private String adminUsername;

    @NotEmpty
    private String adminPassword;

    @NotEmpty
    private String userUsername;

    @NotEmpty
    private String userPassword;

    @NotEmpty
    private String clientId;

    @NotEmpty
    private String clientSecret;
}
```

우리가 외부 파일로 뺄 것은 다음과 같습니다.

* 관리자 계정 이메일과 비밀번호
* 일반 계정 이메일과 비밀번호
* 앱의 클라이언트 아이디와 시크릿 키

여기서 `@ConfigurationProperties` 안에 prefix 값 "my-app"은 반드시 카멜 케이싱이 아닌 - 형식을 써야 합니다. 이제 `application.properties`에 다음 코드를 추가해주세요.

src/main/reources/application.properties
```
# same code

# my-app
my-app.admin-username=admin@emai.com
my-app.admin-password=admin
my-app.user-username=user@email.com
my-app.user-password=user
my-app.client-id=myApp
my-app.client-secret=pass
```

아마 얼티메이트 버전 사용하시는 분들이면, 한 번 빌드해두면, 보다 수월하게 코드를 작성할 수 있을 겁니다. 이제 하드 코딩된 설정들을 이 `AppProperties`를 이용하여 보다 타입세이프한 코드로 바꿔두도록 하겠습니다. 먼저 `AppConfig`에서 기존에 계정 하나를 만드는 코드를 계정 2개 만드는 코드로 변경하겠습니다.

src/main/java/project/configs/AppConfig.java
```java
package com.gurumee.keesunrestapi.configs;

// import

@Configuration
public class AppConifg {
    
    // same code

    @Bean
    public ApplicationRunner applicationRunner(){
        return new ApplicationRunner() {
            @Autowired
            private AccountService accountService;

            // 추가 코드입니다. 외부파일에서 설정한 값들을 이 빈을 통해서 가져옵니다.
            @Autowired
            private AppProperties appProperties;

            @Override
            public void run(ApplicationArguments args) throws Exception {
                //여기서 계정을 2개를 생성하고, appProperties를 통해 계정을 생성합니다.
                Account admin = Account.builder()
                        .email(appProperties.getAdminUsername())
                        .password(appProperties.getAdminPassword())
                        .roles(Set.of(AccountRole.USER, AccountRole.ADMIN))
                        .build();
                accountService.saveAccount(admin);

                Account user = Account.builder()
                        .email(appProperties.getUserUsername())
                        .password(appProperties.getUserPassword())
                        .roles(Set.of(AccountRole.USER))
                        .build();
                accountService.saveAccount(user);
            }
        };
    }
}
```

자, 이제 `AuthServer, AuthServerTest, EventControllerTest`에서 계정을 생성해두는 코드는 클라이언트 아이디 및 시크릿 키를 사용하는 부분을 바꿔주세요. 참고로 `EventContollerTest`에서는 테스트 구동 시마다 데이터를 삭제하니까, 계정을 생성해두어야 정상적으로 테스트가 돌아갑니다. 다음은 각각의 수정된 코드 부분입니다.

src/main/java/project/configs/AuthServer.java
```java
package com.gurumee.keesunrestapi.configs;

// import

@Configuration
@EnableAuthorizationServer
public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {

    //same code

    @Autowired
    private AppProperties appProperties;

    //same code

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        final String clientId = appProperties.getClientId();
        final String clientSecret = appProperties.getClientSecret();

        clients.inMemory()
            .withClient(clientId)
            .authorizedGrantTypes("password", "refresh_token")
            .scopes("read", "write")
            .secret(this.passwordEncoder.encode(clientSecret))
            .accessTokenValiditySeconds(10 * 60)
            .refreshTokenValiditySeconds(6 * 10 * 60)
        ;
    }

    //same code
}
```

src/test/java/project/configs/AuthServerConfigTest.java
```java
package com.gurumee.keesunrestapi.configs;

// import

public class AuthServerConfigTest extends BaseControllerTest {

    @Autowired
    private AccountService accountService;

    @Autowired
    private AppProperties appProperties;

    @Test
    public void 인증_토큰을_발급_받는_테스트() throws Exception{
        
        final String email = appProperties.getUserUsername();
        final String password = appProperties.getUserPassword();

        final String clientId = appProperties.getClientId();
        final String clientSecret = appProperties.getClientSecret();
        this.mockMvc.perform(
                post("/oauth/token")
                    .with(httpBasic(clientId, clientSecret))
                    .param("username", email)
                    .param("password", password)
                    .param("grant_type", "password")
        )
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(jsonPath("access_token").exists())
        .andExpect(jsonPath("token_type").value("bearer"))
        .andExpect(jsonPath("refresh_token").isNotEmpty())
        .andExpect(jsonPath("expires_in").isNumber())
        .andExpect(jsonPath("scope").value("read write"))
                ;
    }
}
```

src/test/java/project/events/EventControllerTest.java
```java
package com.gurumee.keesunrestapi.events;

// import

public class EventControllerTest extends BaseControllerTest {

    // same code

    @Autowired
    private AppProperties appProperties;

    // same code

    private String getAccessToken() throws Exception {
        final String email = appProperties.getUserUsername();
        final String password = appProperties.getUserPassword();
        final Account account = Account.builder()
                .email(email)
                .password(password)
                .roles(Set.of(AccountRole.USER, AccountRole.ADMIN))
                .build();
        this.accountService.saveAccount(account);

        assertThat(password).isEqualTo(account.getPassword());

        final String clientId = appProperties.getClientId();
        final String clientSecret = appProperties.getClientSecret();
        ResultActions perform = this.mockMvc.perform(
                post("/oauth/token")
                        .with(httpBasic(clientId, clientSecret))
                        .param("username", account.getEmail())
                        .param("password", account.getPassword())
                        .param("grant_type", "password")
        );
        MockHttpServletResponse response = perform.andReturn().getResponse();
        String responseBody = response.getContentAsString();
        Jackson2JsonParser parser = new Jackson2JsonParser();
        return parser.parseMap(responseBody).get("access_token").toString();
    }
    // same code
}
```

이렇게 해서 하드 코딩된 설정을 외부 파일을 모두 빼두었습니다. 마찬가지로 테스트를 돌려보면 정상적으로 구동될 것입니다.


## 이벤트 API 점검

이번엔 지금까지 만든 API를 점검해봅시다. Requst URL, Method 필요 정보들을 아래 적어 두었습니다. 한 번 인증된 유저, 인증되지 않은 유저로 나눠서 테스트들을 해보세요.

1. 토큰 얻기
Request: POST /oauth/token
Body: 
{
    "username": "admin@emai.com",
    "password": "admin",
    "grant_type": "password"
}

Authorization: Type Basic Auth
{
    
    "username": "myApp",
    "password": "pass"
}

2. 이벤트 목록 조회
Request: GET /api/events

3. 이벤트 1건 조회
Request: GET /api/events/{id}

4. 이벤트 생성 (인증된 유저만 가능)
Request: POST /api/events
Headers:
{
    "Authorization": "access_token"
}
Body:
{
    "name": "생성할 이벤트 이름"
    "description": "생성할 이벤트 설명"
    "beginEnrollmentDateTime": "생성할 이벤트 등록 시작 날짜"
    "closeEnrollmentDateTime": "생성할 이벤트 등록 종료 날짜"
    "beginEventDateTime": "생성할 이벤트 이벤트 시작 날짜"
    "endEventDateTime": "생성할 이벤트 종료 날짜"
    "location": "생성할 이벤트 장소"
    "basePrice": "생성할 이벤트 기본 요금"
    "maxPrice": "생성할 이벤트 최대 요금"
    "limitOfEnrollment": "생성할 이벤트 등록 제한 인원"
}

5. 이벤트 수정 (인증된 유저만 가능)
Request: PUT /api/events/{id}
Headers:
{
    "Authorization": "access_token"
}
Body:
{
    "name": "수정할 이벤트 이름"
    "description": "수정할 이벤트 설명"
    "beginEnrollmentDateTime": "수정할 이벤트 등록 시작 날짜"
    "closeEnrollmentDateTime": "수정할 이벤트 등록 종료 날짜"
    "beginEventDateTime": "수정할 이벤트 이벤트 시작 날짜"
    "endEventDateTime": "수정할 이벤트 종료 날짜"
    "location": "수정할 이벤트 장소"
    "basePrice": "수정할 이벤트 기본 요금"
    "maxPrice": "수정할 이벤트 최대 요금"
    "limitOfEnrollment": "수정할 이벤트 등록 제한 인원"
}


## 현재 사용자 조회

이번에는 현재 사용자를 조회하기 위해 어댑터를 구현하 후 SpEL을 이용해서 계정을 꺼내오고 그 계정에 따라 링크 정보를 다양하게 제공해보겠습니다. 먼저 우리는 `AccountAdapter`를 구현하겠습니다.

src/main/java/project/accounts/AccountAdapter.java
```java
package com.gurumee.keesunrestapi.accounts;

import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;

import java.util.Collection;
import java.util.Set;
import java.util.stream.Collectors;

@Getter
public class AccountAdapter extends User {

    private Account account;

    public AccountAdapter(Account accout){
        super(accout.getEmail(), accout.getPassword(), authorities(accout.getRoles()));
        this.account = accout;
    }

    private static Collection<? extends GrantedAuthority> authorities(Set<AccountRole> roles) {
        return roles.stream()
                .map( r ->  new SimpleGrantedAuthority("ROLE_" + r.name()))
                .collect(Collectors.toSet());
    }
}
```

스프링 시큐리티의 유저를 상속받고 우리의 Account를 내부 필드로 가지고 있습니다. 이렇게 해두면, UserDetails


## 출력 값 제한하기


## 깨진 테스트 살펴보기

