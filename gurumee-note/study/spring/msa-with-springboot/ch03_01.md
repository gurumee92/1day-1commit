3계층 스프링 부트 애플리케이션 #1
===========

> 책 "스프링 부트를 활용한 마이크로 서비스 개발"을 읽고 정리한 문서입니다. 책은 저자의 노력과 땀의 결과물입니다. 따라서, 책을 사신 분들에게만 참고가 되게끔 문서를 정리하였습니다. 꼭 책을 사서 보시길 바랍니다.

목차
--------

1. 시작하며..
2. 이전 버전 테스트 코드 통과하기
3. 도메인 설계
4. 비지니스 로직 레이어
5. 프레젠테이션 레이어
6. 프론트엔드 개발하기
7. 마치며..

## 시작하며..

이번 장은 3계층 스프링 부트 애플리케이션을 테스트 주도 개발 방식으로 개발하는 것을 설명합니다. 소스 코드는 다음 URL로 이동하여 해당 브랜치를 참고해주세요.

* [URL](https://github.com/gurumee92/msa_with_spring_boot) 브랜치 #EN03

지난 장에서는 스프링 부트를 이용하여 기본적인 애플리케이션을 작성하였습니다. 그러나 실제 애플리케이션은 보통 여러 계층으로 나눈 다중 아키텍처 구조로 개발이 됩니다. 보통 3계층으로 나누는데 다음과 같습니다.

* 클라이언트 계층
* 애플리케이션 계층
* 데이터 저장 계층

우리는 주로 애플리케이션 계층에 대해서 다루는 것을 명심하세요! 이 애플리케이션 계층은 다음의 3개의 레이어로 구분할 수 있습니다.

* 비지니스 레이어
* 프레젠테이션 레이어
* 데이터 레이어

이렇게 여러 계층으로 분리해서 개발하면 무엇이 좋을까요? 책에서는 다음의 세가지로 정리하고 있습니다.

1. 도메인과 솔루션이 분리되어 있어, 인터페이스와, 데이터베이스 명세가 섞여 있지 않습니다.
2. 프레젠테이션 레이어와 데이터 레이어는 다른 레이어로 교체가 가능합니다. 예를 들어 데이터 레이어는 RDBMS 에서 파일 저장 솔루션으로 변경이 가능합니다.
3. 각 레이어의 역할이 명확하게 구분됩니다.

## 이전 버전 테스트 코드 통과하기

자 본격적으로, 이번 장을 진행하기 전에 이전에 못해두었던 작업을 완성하도록 하죠. 바로 `RandomGeneratorServiceImpl`이 없어 빈 주입 시 에러가 나서 테스트를 실패하는 부분인데, 먼저 테스트 코드인 `RandomGeneratorServiceTest`를 작성하도록 하겠습니다.

src/test/java/project/service/RandomGeneratorService.java
```java
package com.gurumee.msa_with_spring_boot.service;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@SpringBootTest
public class RandomGeneratorServiceTest {

    @Autowired
    private RandomGeneratorService randomGeneratorService;

    @Test
    public void generateRandomFactorIsBetweenExpectedLimits() {
        List<Integer> randomFactors = IntStream.range(0, 1000)
                .map( i -> randomGeneratorService.generateRandomFactor() )
                .boxed()
                .collect(Collectors.toList());

        assertThat(randomFactors)
                .containsOnlyElementsOf(
                        IntStream.range(11, 100)
                            .boxed()
                            .collect(Collectors.toList())
                );
    }
}
```

책에서는 테스트 시에 @SpringBootTest 를 남용하지 말라고 써져 있습니다. 왜냐하면, 이 애노테이션이 붙은 테스트들은 모두 스프링 컨텍스트를 초기화한 후 테스트가 구동되는데, 이 때 시간이 꽤 소요되기 때문입니다. 

단지 한 클래스만을 테스트할 것이라면, 이 서비스 인터페이스의 구현 클래스 객체를 생성한 후 단일 테스트 하는 것이 옳습니다. 이를, **유닛 테스트**라고 부릅니다. 이제 유닛 테스트 `RandomGeneratorServiceImplTest` 코드를 작성하겠습니다. 

src/test/java/project/service/RandomGeneratorServiceImplTest.java
```java
package com.gurumee.msa_with_spring_boot.service;

import org.junit.Before;
import org.junit.Test;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;

public class RandomGeneratorServiceImplTest {
    private RandomGeneratorServiceImpl randomGeneratorServiceImpl;

    @Before
    public void setUp() {
        randomGeneratorServiceImpl = new RandomGeneratorServiceImpl();
    }

    @Test
    public void generateRandomFactorIsBetweenExpectedLimits() {
        List<Integer> randomFactors = IntStream.range(0, 1000)
                .map( i -> randomGeneratorServiceImpl.generateRandomFactor() )
                .boxed()
                .collect(Collectors.toList());

        assertThat(randomFactors)
                .containsOnlyElementsOf(
                        IntStream.range(11, 100)
                                .boxed()
                                .collect(Collectors.toList())
                );
    }
}
```

자 이제 테스트를 실행해보면 컴파일도 되지 않습니다. 왜냐하면 `RandomGeneratorServiceImpl` 클래스가 존재하지 않기 때문이죠. 바로 코드 작성을 해보도록 하겠습니다.

src/main/java/project/service/RandomGeneratorServiceImpl.java
```java
package com.gurumee.msa_with_spring_boot.service;

import org.springframework.stereotype.Service;

import java.util.Random;

@Service
public class RandomGeneratorServiceImpl implements RandomGeneratorService {

    private final static int MINIMUM_FACTOR = 11;
    private final static int MAXIMUM_FACTOR = 99;

    @Override
    public int generateRandomFactor() {
        return new Random().nextInt(MAXIMUM_FACTOR - MINIMUM_FACTOR + 1) + MINIMUM_FACTOR;
    }
}
```

이제 테스트를 돌려보면, 모두 통과하는 것을 알 수 있습니다. 이제 `MultiplicationServiceImpl`에 대한 단위 테스트도 작성해보도록 하죠.

src/test/java/project/service/MultiplicationServiceImplTest.java
```java
package com.gurumee.msa_with_spring_boot.service;

import com.gurumee.msa_with_spring_boot.domain.Multiplication;
import com.gurumee.msa_with_spring_boot.domain.MultiplicationResultAttempt;
import com.gurumee.msa_with_spring_boot.domain.User;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.BDDMockito.given;

public class MultiplicationServiceImplTest {
    @Mock
    private RandomGeneratorService randomGeneratorService;

    private MultiplicationServiceImpl multiplicationServiceImpl;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        multiplicationServiceImpl = new MultiplicationServiceImpl(randomGeneratorService);
    }

    @Test
    public void createRandomMultiplicationTest() {
        //given
        final int A = 50;
        final int B = 30;
        given(randomGeneratorService.generateRandomFactor()).willReturn(A, B);

        //when
        Multiplication multiplication = multiplicationServiceImpl.createRandomMultiplication();

        //assert
        assertThat(multiplication.getFactorA()).isEqualTo(A);
        assertThat(multiplication.getFactorB()).isEqualTo(B);
        assertThat(multiplication.getResult()).isEqualTo(A * B);
    }
}
```

## 도메인 설계

자 본격적인 도메인 설계에 앞서, 프로젝트에 롬복을 설정해보도록 하겠습니다. `pom.xml`을 다음과 같이 수정해 주세요.

pom.xml (project root)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<!-- code -->

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
        <!-- 롬복 추가 -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.16.22</version>
		</dependency>
	</dependencies>

	<!-- code -->
</project>
```

이러면 프로젝트에 롬복 라이브러리 의존성이 추가됩니다. 또 IntelliJ 유저라면, 롬복 애노테이션을 활성화시켜주어야 IDE가 제대로 동작하는데, 이는 해당 URL을 참고하세요

* [롬복 설정](https://gmlwjd9405.github.io/2018/11/29/intellij-lombok.html)

롬복 라이브러리는 Java 클래스를 만들 때, getter, setter, toString, constructor 작업을 애노테이션으로 제거 시켜주는 유틸 라이브러리입니다. 우리는 이제 해당 도메인 클래스를 변경하거나 생성해야 합니다.

* Multiplication
* User
* MultiplicationResultAttempt

자 바로 코드를 작성하죠. `Multiplication, User, MultiplicationResultAttempt`순으로 코드를 작성하겠습니다.

src/main/java/project/domain/Multiplication.java
```java
package com.gurumee.msa_with_spring_boot.domain;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@Getter
@ToString
@EqualsAndHashCode
public final class Multiplication {
    private final int factorA;
    private final int factorB;

    public Multiplication() {
        this(0, 0);
    }
}
```

src/main/java/project/domain/User.java
```java
package com.gurumee.msa_with_spring_boot.domain;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@Getter
@ToString
@EqualsAndHashCode
public final class User {

    private final String alias;

    public User() {
        alias = null;
    }
}
```

src/main/java/project/domain/MultiplicationResultAttempt.java
```java
package com.gurumee.msa_with_spring_boot.domain;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@Getter
@ToString
@EqualsAndHashCode
public final class MultiplicationResultAttempt {
    private final User user;
    private final Multiplication multiplication;
    private final int resultAttempt;

    public MultiplicationResultAttempt() {
        user = null;
        multiplication = null;
        resultAttempt = -1;
    }
}
```

위 도메인 클래스들의 기본 생성자를 위 생성해주냐면 JSON 역직렬화시에, 필요하기 때문입니다. 

## 비지니스 로직 레이어

이제 도메인을 변경했으니 비지니스 로직에 입력한 결과가 맞는지 여부를 반환하는 메소드를 추가해 볼까요? 먼저 테스트 코드를 작성해보도록 하겠습니다. `MultiplicationServiceImplTest`를 다음과 같이 변경해주세요.

src/test/java/project/service/MultiplicationServiceImplTest.java
```java
package com.gurumee.msa_with_spring_boot.service;

import com.gurumee.msa_with_spring_boot.domain.Multiplication;
import com.gurumee.msa_with_spring_boot.domain.MultiplicationResultAttempt;
import com.gurumee.msa_with_spring_boot.domain.User;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.BDDMockito.given;

public class MultiplicationServiceImplTest {
    /* 이전과 동일 */

    @Test
    public void checkCorrectAttemptTest() {
        //given
        final int A = 50;
        final int B = 60;
        Multiplication multiplication = new Multiplication(A, B);
        User user = new User("Gurumee");
        MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, A * B);

        boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt);
        assertThat(attemptResult).isTrue();
    }
}
```
이 때, 테스트를 실패합니다. 2개의 이유가 있는데 1개는 `MultiplicationServiceImpl`에 `checkAttempt` 메소드가 없기 때문이고, 이전 코드에서
 
```java
    @Test
    public void createRandomMultiplicationTest() {
        //given
        final int A = 50;
        final int B = 30;
        given(randomGeneratorService.generateRandomFactor()).willReturn(A, B);

        //when
        Multiplication multiplication = multiplicationServiceImpl.createRandomMultiplication();

        //assert
        assertThat(multiplication.getFactorA()).isEqualTo(A);
        assertThat(multiplication.getFactorB()).isEqualTo(B);
        assertThat(multiplication.getResult()).isEqualTo(A * B); // <- 문제가 되는 코드
    }
```

도메인 `Mulitplication`에서 `result` 필드가 제거됐기 때문에 "multiplication.getResult()" 부분이 오류를 내기 때문입니다. 일단 `MultiplicationServiceTest, MultiplicationServiceImplTest`에서 "multiplication.getResult()" 이 부분을 제거 해주세요. 그 후 `MultiplicationService`, `MultiplicationServiceImpl` 코드를 다음과 같이 수정해주세요.

src/main/java/project/service/MultiplicationService.java
```java
package com.gurumee.msa_with_spring_boot.service;

import com.gurumee.msa_with_spring_boot.domain.Multiplication;
import com.gurumee.msa_with_spring_boot.domain.MultiplicationResultAttempt;

public interface MultiplicationService {
    Multiplication createRandomMultiplication();

    //추가
    boolean checkAttempt(final MultiplicationResultAttempt resultAttempt);
}
```

src/main/java/project/service/MultiplicationServiceImpl.java
```java
package com.gurumee.msa_with_spring_boot.service;

import com.gurumee.msa_with_spring_boot.domain.Multiplication;
import com.gurumee.msa_with_spring_boot.domain.MultiplicationResultAttempt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MultiplicationServiceImpl implements MultiplicationService{

    /* 이전과 동일 */

    @Override
    public boolean checkAttempt(MultiplicationResultAttempt resultAttempt) {
        final int result = resultAttempt.getResultAttempt();
        Multiplication multiplication = resultAttempt.getMultiplication();
        final int A = multiplication.getFactorA();
        final int B = multiplication.getFactorB();
        return result == (A * B);
    }
}
```

자 이제 테스트를 돌려보시면 모든 테스트가 통과되는 것을 확인 할 수 있습니다!

## 프레젠테이션 레이어
## 프론트엔드 개발하기
## 마치며..
