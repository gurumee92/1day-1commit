# 열거 타입과 애너테이션

![대표사진](./images/intro.png)

> 책 "이펙티브 자바 3판"을 공부하면서 정리한 문서입니다.

- [열거 타입과 애너테이션](#열거-타입과-애너테이션)
  - [상수 대신 열거 타입을 사용하라](#상수-대신-열거-타입을-사용하라)
  - [ordinal 메서드 대신 인스턴스 필드를 사용하라](#ordinal-메서드-대신-인스턴스-필드를-사용하라)
  - [비트 필드 대신 EnumSet을 사용하라](#비트-필드-대신-enumset을-사용하라)
  - [ordinal 메서드 대신 EnumMap을 사용하라](#ordinal-메서드-대신-enummap을-사용하라)
  - [확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라](#확장할-수-있는-열거-타입이-필요하면-인터페이스를-사용하라)
  - [명명 패턴보다 애너테이션을 사용하라](#명명-패턴보다-애너테이션을-사용하라)
  - [@Override 애너테이션을 일관되게 사용하라](#override-애너테이션을-일관되게-사용하라)
  - [정의하는 것이 타입이라면 마커 인터페이스를 사용하라](#정의하는-것이-타입이라면-마커-인터페이스를-사용하라)

이번 장은 자바 언어의 심장인 `클래스`와 `인터페이스`에 대해서 공부한다.


## 상수 대신 열거 타입을 사용하라

가장 쉬운 열거 패턴으로는 `정수 열거 패턴`이 있다.

```java
public static final int APPLE_FUJI = 0;
public static final int APPLE_PINPIN = 1;
public static final int APPLE_GRANNY_SMITH = 2;

public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_TEMPLE = 0;
public static final int ORANGE_BLOOD = 0;
```

이 코드의 경우 대표적으로 2가지 단점이 존재한다.

1. 표현력이 좋지 않다.
2. 타입 안전을 보장할 수 없다.

예컨대, 이런 코드를 짜더라도 컴파일러는 문제를 발생시키지 않는다.

```java
int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PINPIN; 
```

코드를 보면 사과용 상수를 건네어야 할 것 같은데, 오렌지용 상수를 건네더라도 아무 문제가 발생하지 않는다. 이런 열거 패턴 외에 `문자형 열거 패턴`도 있지만 이것 역시 `정수 열거 패턴`의 단점을 극복하지 못한다.

자바는 `enum type`을 제공한다. C, C++, C#과 달리 자바에서 `enum`은 클래스이며, 상수 하나 당 인스턴스를 `public static final` 필드로 공개한다. 생성자를 `private` 레벨로 만들기 때문에 사실 상 인스턴스가 `final`로 볼 수 있다.

자바의 `enum`이 클래스이기 때문에, 가지는 장점이 있다. 바로 메서드를 가질 수 있다는 것이다. 다음을 살펴보자.

```java
public enum Operation {
    PLUS {
        @Override
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS {
        @Override
        public double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES {
        @Override
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE {
        @Override
        public double apply(double x, double y) {
            return x / y;
        }
    };

    public abstract double apply(double x, double y);
}
```

`Operation` 열거 타입은, 상수로 `PLUS(덧셈), MINUS(뺄셈), TIMES(곱셈), DIVIDE(나눗셈)`을 가진다. 이들은 상수임을 나타낼 뿐 아니라 저마다의 메서드 `apply`를 가진다. 각 상수마다 적용된 `apply` 메소드는 다른 방식으로 작동한다.

간단하게 테스트해보자.

```java
public class Item34Test {
    @Test
    @DisplayName("Operation Test")
    public void test01() {
        double x = 2.0;
        double y = 4.0;

        assertEquals(x + y, Operation.PLUS.apply(x, y));
        assertEquals(x - y, Operation.MINUS.apply(x, y));
        assertEquals(x * y, Operation.TIMES.apply(x, y));
        assertEquals(x / y, Operation.DIVIDE.apply(x, y));
    }
}
```

각 상수의 연산에 맞게 잘 동작하는 것을 확인할 수 있다. **이를 `상수별 메서드 구현(constant-specific method implementation)`이라 한다.**

그렇다면 제일 중요한 것. 열거 타입은 언제 사용해야 할까? 

답은 필요한 원소를 컴파일 타임에 다 알 수 있는 상수 집합일 때는 무조건 열거 타입을 사용한다. 예를 들어, 체스 말, 메뉴 아이템 연산 코드, 명령 줄 플래그 등이 있다.


## ordinal 메서드 대신 인스턴스 필드를 사용하라

## 비트 필드 대신 EnumSet을 사용하라

## ordinal 메서드 대신 EnumMap을 사용하라

## 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

## 명명 패턴보다 애너테이션을 사용하라

## @Override 애너테이션을 일관되게 사용하라

## 정의하는 것이 타입이라면 마커 인터페이스를 사용하라