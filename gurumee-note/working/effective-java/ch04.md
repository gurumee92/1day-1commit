# 클래스와 인터페이스

![대표사진](./images/intro.png)

> 책 "이펙티브 자바 3판"을 공부하면서 정리한 문서입니다.

## 목차

- [클래스와 인터페이스](#클래스와-인터페이스)
  - [목차](#목차)
  - [클래스와 멤버의 접근 권한을 최소화하라](#클래스와-멤버의-접근-권한을-최소화하라)
  - [public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
  - [변경 가능성을 최소화하라](#변경-가능성을-최소화하라)
  - [상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라](#상속을-고려해-설계하고-문서화하라-그렇지-않았다면-상속을-금지하라)
  - [추상 클래스보다는 인터페이스를 우선하라](#추상-클래스보다는-인터페이스를-우선하라)
  - [인터페이스는 구현하는 쪽을 생각해 설계하라](#인터페이스는-구현하는-쪽을-생각해-설계하라)
  - [인터페이스는 타입을 정의하는 용도로만 사용하라](#인터페이스는-타입을-정의하는-용도로만-사용하라)
  - [태그 달린 클래스보다는 클래스 계층구조를 활용하라](#태그-달린-클래스보다는-클래스-계층구조를-활용하라)
  - [멤버 클래스는 되도록 static으로 만들라](#멤버-클래스는-되도록-static으로-만들라)
  - [톱레벨 클래스는 한 파일에 하나만 담으라](#톱레벨-클래스는-한-파일에-하나만-담으라)

이번 장은 자바 언어의 심장인 `클래스`와 `인터페이스`에 대해서 공부한다.


## 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 캡슐화를 얼마나 잘 했는지에 따라 달려있다. 캡슐화의 장점은 다음과 같다.

* 시스템 개발 속도를 높인다.
* 시스템 관리 비용을 낮춘다.
* 간접적으로 성능 최적화에 도움을 준다.
* 소프트웨어 재사용성을 높인다.
* 큰 시스템을 제작하는 난이도를 낮춘다.

자바는 클래스, 인터페이스, 접근 제한자를 통해서 캡슐화를 지원한다. 책에 따르면, 기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다**라고 명시되어 있다. 자바 코드의 접근 범위는 다음과 같다.

* private : 멤버를 선언한 톱레벨 클래스에서만 접근 가능.
* package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능.
* protected : package-private 접근 범위를 포함. 이 멤버를 선언한 클래스 하위 클래스에도 접근이 가능하다.
* public : 모든 곳에서 접근이 가능하다.

이와 관련하여 코드를 작성할 때 몇가지 팁이 있다.

1. 테스트 목적을 위해 private 접근 제한자를 package-private 이상으로 넓히지 마라.
2. public 클래스의 인스턴스 필드 및 접근자 메소드는 되도록 public으로 만들지 마라.(상수 제외)

1번째 팁은 당연하다. 테스트를 위해서 `private` 접근 제한자인 필드 혹은 메소드에 대해서 테스트할 때, 접근이 안되므로 `package-private` 수준으로 올려야 할 수도 있다. 개인적으로 이 경우는 추천하지는 않는다. `private`은 `private`일 때 아름다운 것이다. 2번째 팁의 경우를 살펴보자. 클래스 안에 인스턴스 필드로 배열이 있다고 생각해보자.

```java
public class PublicArrayExample {
    public static Integer[] PRIVATE_VALUES = {
            1, 2, 3, 4
    };
}
```

이 배열은 가변적이며 **스레드에 안전하지 않다.** 이를 해결하기 위해서, 접근 제한자를 private, 그리고 변하지 못하도록 정적 멤버 필드로 바꿔주는 것이 좋다. 다음과 같이 말이다.

```java
public class PublicArrayExample {
    private final static Integer[] PRIVATE_VALUES = {
            1, 2, 3, 4
    };
}
```

이 경우, 어쩔 수 없이 접근을 허용해야 하는 경우가 생기는데, 이를 해결하기 위해서는 다음의 두가지 방법이 있다.

1. private static으로 만들고 public 불변 리스트를 추가한다.
2. private static으로 만들고 복사본 접근 제한자를 만든다.

코드로 살펴보자.

```java
public class PublicArrayExample {
    private final static Integer[] PRIVATE_VALUES = {
            1, 2, 3, 4
    };

    // 1번 방법
    public static final List<Integer> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

    // 2번 방법
    public static final Integer[] values() {
        return PRIVATE_VALUES.clone();
    }
}
```

`PRIVATE_VALUES`를 접근 시켜주기 위해서, 이를 불변 리스트로 만들어서 상수 필드로 제공하는 방법과, 이를 복사해서 넘겨주는 방법이 있다. 어느 것을 선택할지는 자신의 상황에 맞춰 편한 것을 쓰면 된다. 

추가적으로 `자바9`에 추가된 "모듈 시스템" 개념 때문에 접근 보호 방법이 더 추가되었다. 하지만, 이를 고려하는 방법은 아직 시기 상조이니 얕게도 알아보지 말고 넘어가자.


## public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

이따금, 인스턴스 필드를 모아놓는 일 외에 아무 목적이 없는 클래스를 작성할 때가 있다.

```java
public class Point {
    public Double x;
    public Double y;
}
```

이 경우, "캡슐화의 이점을 제공하지 못한다". 이 때의 단점은 다음과 같다.

* API 수정 외에 내부 표현을 바꿀 수 없다.
* 불변식을 보장할 수 없다.
* 부수 작업을 수행할 수 없다.

그렇다면 이를 해결하기 위해서는 어떻게 해야 할까. 단순하다. 필드는 private으로 바꾸고 이들에 대한 접근 제어 메소드를 public 수준으로 제공하면 된다. 다음과 같이 말이다.

```java
package ch04;

public class Point {
    private Double x;
    private Double y;
    
    public Point(Double x, Double y) {
        this.x = x;
        this.y = y;
    }

    public Double getX() {
        return x;
    }

    public void setX(Double x) {
        this.x = x;
    }

    public Double getY() {
        return y;
    }

    public void setY(Double y) {
        this.y = y;
    }
}
```

하지만, package-private 클래스 혹은 private 중첩 클래스라면, **데이터 필드를 노출해도 문제 될 것은 없다**. 다시 정리한다.

**public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.** 그러나 package-private 혹은 private 중첩 클래스는 종종 필드를 노출하는 편이 나을 때가 있다.


## 변경 가능성을 최소화하라

## 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라

## 추상 클래스보다는 인터페이스를 우선하라

## 인터페이스는 구현하는 쪽을 생각해 설계하라

## 인터페이스는 타입을 정의하는 용도로만 사용하라

## 태그 달린 클래스보다는 클래스 계층구조를 활용하라

## 멤버 클래스는 되도록 static으로 만들라

## 톱레벨 클래스는 한 파일에 하나만 담으라
