# 클래스와 인터페이스

![대표사진](./images/intro.png)

> 책 "이펙티브 자바 3판"을 공부하면서 정리한 문서입니다.

## 목차

- [클래스와 인터페이스](#클래스와-인터페이스)
  - [목차](#목차)
  - [클래스와 멤버의 접근 권한을 최소화하라](#클래스와-멤버의-접근-권한을-최소화하라)
  - [public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
  - [변경 가능성을 최소화하라](#변경-가능성을-최소화하라)
  - [상속보다는 컴포지션을 사용하라](#상속보다는-컴포지션을-사용하라)
  - [상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라](#상속을-고려해-설계하고-문서화하라-그렇지-않았다면-상속을-금지하라)
  - [추상 클래스보다는 인터페이스를 우선하라](#추상-클래스보다는-인터페이스를-우선하라)
  - [인터페이스는 구현하는 쪽을 생각해 설계하라](#인터페이스는-구현하는-쪽을-생각해-설계하라)
  - [인터페이스는 타입을 정의하는 용도로만 사용하라](#인터페이스는-타입을-정의하는-용도로만-사용하라)
  - [태그 달린 클래스보다는 클래스 계층구조를 활용하라](#태그-달린-클래스보다는-클래스-계층구조를-활용하라)
  - [멤버 클래스는 되도록 static으로 만들라](#멤버-클래스는-되도록-static으로-만들라)
  - [톱레벨 클래스는 한 파일에 하나만 담으라](#톱레벨-클래스는-한-파일에-하나만-담으라)

이번 장은 자바 언어의 심장인 `클래스`와 `인터페이스`에 대해서 공부한다.


## 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 캡슐화를 얼마나 잘 했는지에 따라 달려있다. 캡슐화의 장점은 다음과 같다.

* 시스템 개발 속도를 높인다.
* 시스템 관리 비용을 낮춘다.
* 간접적으로 성능 최적화에 도움을 준다.
* 소프트웨어 재사용성을 높인다.
* 큰 시스템을 제작하는 난이도를 낮춘다.

자바는 클래스, 인터페이스, 접근 제한자를 통해서 캡슐화를 지원한다. 책에 따르면, 기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다**라고 명시되어 있다. 자바 코드의 접근 범위는 다음과 같다.

* private : 멤버를 선언한 톱레벨 클래스에서만 접근 가능.
* package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능.
* protected : package-private 접근 범위를 포함. 이 멤버를 선언한 클래스 하위 클래스에도 접근이 가능하다.
* public : 모든 곳에서 접근이 가능하다.

이와 관련하여 코드를 작성할 때 몇가지 팁이 있다.

1. 테스트 목적을 위해 private 접근 제한자를 package-private 이상으로 넓히지 마라.
2. public 클래스의 인스턴스 필드 및 접근자 메소드는 되도록 public으로 만들지 마라.(상수 제외)

1번째 팁은 당연하다. 테스트를 위해서 `private` 접근 제한자인 필드 혹은 메소드에 대해서 테스트할 때, 접근이 안되므로 `package-private` 수준으로 올려야 할 수도 있다. 개인적으로 이 경우는 추천하지는 않는다. `private`은 `private`일 때 아름다운 것이다. 2번째 팁의 경우를 살펴보자. 클래스 안에 인스턴스 필드로 배열이 있다고 생각해보자.

```java
public class PublicArrayExample {
    public static Integer[] PRIVATE_VALUES = {
            1, 2, 3, 4
    };
}
```

이 배열은 가변적이며 **스레드에 안전하지 않다.** 이를 해결하기 위해서, 접근 제한자를 private, 그리고 변하지 못하도록 정적 멤버 필드로 바꿔주는 것이 좋다. 다음과 같이 말이다.

```java
public class PublicArrayExample {
    private final static Integer[] PRIVATE_VALUES = {
            1, 2, 3, 4
    };
}
```

이 경우, 어쩔 수 없이 접근을 허용해야 하는 경우가 생기는데, 이를 해결하기 위해서는 다음의 두가지 방법이 있다.

1. private static으로 만들고 public 불변 리스트를 추가한다.
2. private static으로 만들고 복사본 접근 제한자를 만든다.

코드로 살펴보자.

```java
public class PublicArrayExample {
    private final static Integer[] PRIVATE_VALUES = {
            1, 2, 3, 4
    };

    // 1번 방법
    public static final List<Integer> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

    // 2번 방법
    public static final Integer[] values() {
        return PRIVATE_VALUES.clone();
    }
}
```

`PRIVATE_VALUES`를 접근 시켜주기 위해서, 이를 불변 리스트로 만들어서 상수 필드로 제공하는 방법과, 이를 복사해서 넘겨주는 방법이 있다. 어느 것을 선택할지는 자신의 상황에 맞춰 편한 것을 쓰면 된다. 

추가적으로 `자바9`에 추가된 "모듈 시스템" 개념 때문에 접근 보호 방법이 더 추가되었다. 하지만, 이를 고려하는 방법은 아직 시기 상조이니 얕게도 알아보지 말고 넘어가자.


## public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

이따금, 인스턴스 필드를 모아놓는 일 외에 아무 목적이 없는 클래스를 작성할 때가 있다.

```java
public class Point {
    public Double x;
    public Double y;
}
```

이 경우, "캡슐화의 이점을 제공하지 못한다". 이 때의 단점은 다음과 같다.

* API 수정 외에 내부 표현을 바꿀 수 없다.
* 불변식을 보장할 수 없다.
* 부수 작업을 수행할 수 없다.

그렇다면 이를 해결하기 위해서는 어떻게 해야 할까. 단순하다. 필드는 `private` 수준으로 바꾸고 이들에 대한 접근 제어 메소드를 `public` 수준으로 제공하면 된다. 다음과 같이 말이다.

```java
package ch04;

public class Point {
    private Double x;
    private Double y;
    
    public Point(Double x, Double y) {
        this.x = x;
        this.y = y;
    }

    public Double getX() {
        return x;
    }

    public void setX(Double x) {
        this.x = x;
    }

    public Double getY() {
        return y;
    }

    public void setY(Double y) {
        this.y = y;
    }
}
```

하지만, `package-private` 클래스 혹은 `private 중첩` 클래스라면, **데이터 필드를 노출해도 문제 될 것은 없다**. 다시 정리한다.

**`public` 클래스는 절대 가변 필드를 직접 노출해서는 안된다.** 그러나 `package-private` 혹은 `private 중첩` 클래스는 종종 필드를 노출하는 편이 나을 때가 있다.


## 변경 가능성을 최소화하라

`String`, `BigInteger`, `BigDecimal` 같은 불변 클래스들이 있다. 이들은, 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지가 적고 훨씬 안전하다. 이를 만들 때 다섯 가지 규칙이 있다.

1. 클래스의 상태를 변경하는 메소드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필들르 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.

다음 예를 살펴보자.

```java
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    public double realPart() {
        return this.re;
    }

    public double imaginaryPart() {
        return this.im;
    }

    public Complex plus(Complex c) {
        return new Complex(this.re + c.re, this.im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(this.re - c.re, this.im - c.im);
    }

    public Complex times(Complex c) {
        double re = this.re * c.re - this.im * c.im;
        double im = this.re * c.im + this.im * c.re;
        return new Complex(re, im);
    }

    public Complex divides(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        double re = (this.re * c.re + this.im * c.im) / tmp;
        double im = (this.im * c.re - this.re * c.im) / tmp;
        return new Complex(re, im);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if (!(o instanceof Complex)) {
            return false;
        }

        Complex c = (Complex) o;
        return Double.compare(this.re, c.re) == 0 && Double.compare(this.im, c.im) == 0;
    }

    @Override
    public int hashCode(){
        return 31 * Double.hashCode(this.re) + Double.hashCode(this.im);
    }

    @Override
    public String toString() {
        return "(" + this.re + " + " + this.im + "i)";
    }
}
```

위 클래스의 사칙 연산 메소드를 보자. 이들은, **자신의 필드를 변경하지 않고 새로운 `Complex `인스턴스를 반환한다.** 이처럼 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 `함수형 프로그래밍`이라고 부른다.

이렇게 만들면 좋은게, 불변 객체는 근본적으로 불변이기 때문에, 스레드에 안전하고 따로 동기화할 필요가 없다. 또한 불변 객체끼리 내부 데이터를 공유할 수 있다. 그러나 이런 불변 클래스 역시 단점이 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다는 점이다.

그래도 단점보단 장점이 훨씬 많기 때문에.. **클래스는 꼭 필요한 경우가 아니라면 불변으로 만드는 것이 좋다**. 또한, 불변으로 만들 수 없는 클래스일지라도, 변경할 수 있는 부분을 최소한으로 줄이는 것이 좋다.


## 상속보다는 컴포지션을 사용하라

## 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라

## 추상 클래스보다는 인터페이스를 우선하라

## 인터페이스는 구현하는 쪽을 생각해 설계하라

## 인터페이스는 타입을 정의하는 용도로만 사용하라

## 태그 달린 클래스보다는 클래스 계층구조를 활용하라

## 멤버 클래스는 되도록 static으로 만들라

## 톱레벨 클래스는 한 파일에 하나만 담으라
