# 정규화 vs 역정규화

## 정규화란

정규화란 테이블을 올바른 형태로 변경하고 분할하는 것을 말한다. 쉽게 말해서 "하나의 데이터를 한 곳에 저장" 혹은 "중복 데이터를 제거"하는 것이 목적이다. 예를 들어보자.

주문 상품 별 수량과 고객 정보 테이블
| 주문 번호 | 날짜 | 성명 | 연락처 | 주문 상품 |
| :-- | :-- | :-- | :-- | :-- |
| 1 | 1/1 | 구르미 | 010-xxxx-xxxx | 0001 OO 1개, 0002 xx 2개 |
| 2 | 1/2 | 브래든 | 010-xxxx-xxxx | 0001 OO 2개, 0002 xx 3개 |
| 3 | 1/2 | 구르미 | 010-xxxx-xxxx | 0001 OO 3개, 0003 xo 1개 |

이 테이블의 단점들이 많다. 제일 큰 문제는 주문 상품에 문자와 수량이 섞여 있다는 것이다. 

**제 1정규화 적용**

제 1정규화는 첫 번째 단계는 반복되는 데이터를 가로가 아닌 세로로 늘리는 것이다. 중복이 되건 말건 일단 레코드 별로 분리하는 것이다.

| 주문 번호 | 날짜 | 성명 | 연락처 | 상품 코드 | 상품명 | 개수 |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| 1 | 1/1 | 구르미 | 010-xxxx-xxxx | 0001  | OO  | 1 | 
| 1 | 1/1 | 구르미 | 010-xxxx-xxxx | 0002  | xx  | 2 | 
| 2 | 1/2 | 브래든 | 010-xxxx-xxxx | 0001  | OO  | 2 | 
| 2 | 1/2 | 브래든 | 010-xxxx-xxxx | 0002  | xx  | 3 | 
| 3 | 1/2 | 구르미 | 010-xxxx-xxxx | 0001  | OO  | 3 | 
| 3 | 1/2 | 구르미 | 010-xxxx-xxxx | 0003  | xo  | 1 | 

이제 중복되는 데이터들을 테이블로 분리하고 테이블간 릴레이션을 맺어준다.

주문 테이블
| 주문 번호 | 날짜 | 성명 | 연락처 |
| :-- | :-- | :-- | :-- |
| 1 | 1/1 | 구르미 | 010-xxxx-xxxx |
| 2 | 1/2 | 브래든 | 010-xxxx-xxxx |
| 3 | 1/2 | 구르미 | 010-xxxx-xxxx |

주문 상품 테이블
| 주문 번호 | 상품 코드 | 상품명 | 개수 |
| :-- | :-- | :-- | :-- |
| 1 | 0001  | OO  | 1 | 
| 1 | 0002  | xx  | 2 | 
| 2 | 0001  | OO  | 2 | 
| 2 | 0002  | xx  | 3 | 
| 3 | 0001  | OO  | 3 | 
| 3 | 0003  | xo  | 1 | 

**제 2정규화 적용**

제 2정규화는 제 1정규화를 만족하면서 부분 함수적 종속을 제거하여 모든 속성이 기본키에 완전 함수 종속이 되도록 하는 것이다. 예를 들어 주문 상품 테이블을 보자. 이는 또 이렇게 분리할 수 있다.

주문 상품 테이블
| 주문 번호 | 상품 코드 | 개수 |
| :-- | :-- | :-- | 
| 1 | 0001  | 1 | 
| 1 | 0002  | 2 | 
| 2 | 0001  | 2 | 
| 2 | 0002  | 3 | 
| 3 | 0001  | 3 | 
| 3 | 0003  | 1 | 

사실, 주문 상품 테이블에는 상품명이 필요가 없다. 코드로써 이미 "상품"이 구별되기 때문이다. 따라서, 상품 테이블을 하나 더 만든다.

상품 테이블
| 상품 코드 | 상품명 | 
| :-- | :-- |
| 0001 | OO |
| 0002 | xx |
| 0003 | xo |

**제 3정규화 적용**

제 2정규화를 만족하면서 릴레이션을 구성하는 속성들 간의 이행적 종속관계를 분해하여 속성들이 비이행적 함수 종속관계를 만족하게 만드는 것이다. 주문 테이블을 다시 보자.

주문 테이블
| 주문 번호 | 날짜 | 성명 | 연락처 |
| :-- | :-- | :-- | :-- |
| 1 | 1/1 | 구르미 | 010-xxxx-xxxx |
| 2 | 1/2 | 브래든 | 010-xxxx-xxxx |
| 3 | 1/2 | 구르미 | 010-xxxx-xxxx |

여기서 "구르미"라는 사람이 반복이 된다. 이런 중복 데이터를 분리해내는 것이다. 주문 테이블은, 주문과 고객 테이블로 분리된다.

주문 테이블
| 주문 번호 | 날짜 | 고객 번호 |
| :-- | :-- | :-- | 
| 1 | 1/1 | 01 |
| 2 | 1/2 | 02 |
| 3 | 1/2 | 01 |

고객 테이블
| 고객 번호 | 성명 |
| :-- | :-- | 
| 01 | 구르미 |
| 02 | 브랜든 |

이렇게 단계별로 정규화를 거치면, 중복 데이터가 제거된다. 하지만 릴레이션을 맺고 있기 때문에, 검색도 여전히 가능하며 과하지만 않으면 성능 역시 향상된다. 이후에 제 4정규화, 제 5정규화가 있지만, 보통 제 3정규화까지 쓰기 때문에 따로 정리는 하지 않겠다.


## 역정규화란

역정규화란 정규화를 통해 분리되었던 릴레이션에서 중복을 허용하고 다시 통합하거나 분할하여 구조를 재조정하는 과정이다. 역정규화를 하는 가장 큰 이유는 너무 과한 정규화는 데이터베이스 성능을 낮추기 때문이다. 역정규화의 종류는 다음과 같다.


1) 릴레이션 역정규화
    * 릴레이션 병합: 두 릴레이션 간의 잦은 참조로 성능이 저하될 경우 이 문제점을 해결하기 위해 병합.
    * 릴레이션 분할: 자주 사용하지 않는 속성이나 튜플이 릴레이션에 있을 경우 검색시 성능을 저하하기 때문에 자주 사용하는 속성이나 튜플을 분해.
2) 속성 역정규화
   * 파생 속성(Delivered Attribute): 현재 릴레이션에는 없는 속성이지만 작업의 효율을 위해 힌 속성으로부터의 계산이나 가공에 의해 파생되는 속성.