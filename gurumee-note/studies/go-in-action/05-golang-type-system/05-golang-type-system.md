# Go의 타입 시스템

![대표사진](../logo.png)

> 책 "Go In Action"을 공부하면서 정리한 문서입니다.


- [Go의 타입 시스템](#go의-타입-시스템)
  - [기본 타입과 참조 타입](#기본-타입과-참조-타입)
  - [사용자 정의 타입](#사용자-정의-타입)
  - [구조체와 메서드](#구조체와-메서드)
  - [구조체와 인터페이스](#구조체와-인터페이스)
  - [구조체와 타입 임베딩](#구조체와-타입-임베딩)


## 기본 타입과 참조 타입

`Go`의 타입은 크게 2가지로 나눌 수 있다. 기본 타입과 참조 타입이다. 이 둘은 또 이렇게 분류할 수 있겠다.

* 기본 타입 : int, float, bool, rune 등의 값 표현 타입, 포인터, 배열, string
* 참조 타입 : 구조체, 인터페이스, 슬라이스, 맵, 채널, 함수

이 둘의 차이점은 참조 타입은 기본적으로 헤더 값을 가지고 있다. 기술적으로 보면 문자열을 표현하는 `string` 역시 참조 타입으로 볼 수 있다. 그러나, 동작하는 것은 기본 타입에 가까워서 기본 타입으로 분류하였다.


## 사용자 정의 타입

기본 타입 외, 타입을 정의하는 방법은 크게 2가지이다. 바로 `구조체`와 `타입 재정의`이다. 타입 재정의는 있는 타입을 다시 정의하는 것이다. 다음처럼 말이다.

```go
type MyInt int
```

이는 `int` 타입을 `MyInt`로 타입을 재정의한 것이다. 실제로 이런 식으로 초기화할 수 있다.

```go
var i1, i2 MyInt
i1 = 5
i2 = MyInt(5)
```

그런데 원래 타입을 다시 할당하면 컴파일 에러가 뜬다.

```go
var i3 int = 5
i1 = i3 // 이러면 컴파일 에러
```

왜냐하면 `MyInt` 타입에 `int` 값을 할당했기 때문이다. 둘은 엄연히 다른 타입이기 때문에 타입 캐스팅을 하지 않는 한 이런 식의 할당은 불가능하다. 또 다른 방법은 구조체이다. 구조체는 여러 타입을 한 타입으로 묶을 수 있다. 다음처럼 말이다.

```go
type Point struct {
	X int
	Y int
}
```

여기서, `X`, `Y`를 구조체의 "멤버 필드"라고 부른다. 내부의 속성을 가리킨다. 위의 예제는 `int` 타입 두 개를 묶어주었지만, 여러 타입은 물론 다른 구조체, 인터페이스까지 묶을 수 있다. 초기화는 다음의 2가지 방식이 있다.

```go
p1 := Point{
    X: 1,
    Y: 2,
}
p2 := Point{4, 1}
```

첫 번째 방식은 멤버 필드를 명시적으로 선언해서 초기화한다. 두 번째 방식은 선언한 순서대로 초기화된다. 첫 번째 방식에선, `X`, `Y`의 순서가 바뀌어도 구조체의 값은 같지만 두 번째 방식에선 `X`, `Y`의 값이 바뀐다.


## 구조체와 메서드

## 구조체와 인터페이스

## 구조체와 타입 임베딩




