# 배열, 슬라이스, 맵

![대표사진](../logo.png)

> 책 "Go In Action"을 공부하면서 정리한 문서입니다.

## 목차
  - [배열](#배열)
  - [슬라이스](#슬라이스)
  - [맵](#맵)


## 배열

`Go`에서 배열은 컬렉션을 다루는 `슬라이스`, `맵`의 기본이 되는 타입이다. 배열은 다음과 같이 만들 수 있다.

```go
arr := [5]int{1, 2, 3, 4, 5}
```

요령은 다음과 같다.

```
[배열의 길이]타입{ 값1, 값2, ... }
```

배열의 길이만큼 값을 초기화할 수 있다. `[]` 연산자로 원소에 접근할 수 있다.

```go
fmt.Println(a[2]) // 3 출력
a[2] = 999
fmt.Println(a[2]) // 999 출력
```

내장 함수 `len`을 통해서 배열의 길이를 알 수 있다.

```go
size := len(arr)
fmt.Println(size) // 5 출력
```

배열을 순회하는 방법은 크게 2가지가 있다. 먼저 첫 번째는, 기존 코드 처럼, 인덱스를 길이만큼 순회하는 것이다.

```go
for i:=0; i<len(arr); i++ {
    fmt.Println(a[i])
}
```

두 번째 방법은 이제 많은 언어들이 지원하는 `for-each` 구문이다. `range` 키워드를 사용하면 된다. `range`는 2개의 결과를 반환하는데, 첫번째는 idx, 두번째는 value를 나타낸다.

```go
for idx, value := range arr {
    fmt.Println(idx, value)
}
```

위 코드의 출력문은 다음과 같다.

```
0 1
1 2
2 999
3 4
4 5
```

생략을 하고 싶다면, "_"을 쓰면 된다. 여기서 제일 중요한 것. **`Go`에서 배열은 값이다.** 정확하게 말해서 함수로 전달했을 때, 값으로 취급된다.

```go
func SetIndexCallByValue(a [5]int) {
	a[2] = 6
}
// ...

SetIndexCallByValue(arr)
fmt.Println(arr[2]) // 999 출력
```

값으로 취급된다는 것은 `SetIndexCallByValue` 함수에 `arr`을 매개 변수로 준다고 해보자. 그러면 새로운 변수 `a`에 `arr`의 크기와 원소가 같은 새로운 배열을 만든다. 그 후 그 배열의 인덱스 2에 6을 할당한다. `a`의 인덱스 2가 바뀐 것이지 `arr`의 인덱스 2가 바뀐게 아니다.

함수에 배열을 전달하는 것은 큰 문제가 있다. 만약, 배열의 길이와 크기가 엄청나게 큰다고 했을 때, 함수를 호출할 때마다, 그 큰 배열을 새롭게 만드는 것이다. 이를 해결하는 것은 주소로 전달하는 것이다. 이를 포인터라 한다.

```go
func SetIndexCallByPoint(a *[5]int) {
	a[2] = 6
}
// ...

SetIndexCallByPoint(&arr)
fmt.Println(arr[2]) //6 출력
```

뭐 이건 포인터 설명할 기회가 있겠지..


## 슬라이스

슬라이스는 쉽게 말해서 가변 길이 배열이다. 자바의 `ArrayList`와 유사하다. 기본적인 사용법은 배열과 같다. 슬라이스 생성은 다음과 같다.

```go
s1 := []int{1, 2, 3, 4}
```

배열은 생성 시 `[]`안에 길이를 전달하지만, 슬라이스는 전달하지 않는다. 또한, `make` 내장 함수로 만들 수도 있다.


```go
s2 := make([]int, 0)
```

이러면, 길이 0짜리 슬라이스를 만드는 것이다. 배열처럼 `len`을 이용해서 길이를 알 수 있고 `cap`을 이용해서 내부 배열의 크기를 알 수 있다. 원소 추가는 `append` 함수를 이용해서 할 수 있다.

```go
s1 = append(s1, 5)
```

슬라이스는 배열과 다르게 또 잘라낼 수가 있다.

```go
s3 := s1[2:4] // { 3, 4 }
```

그러면, s1 인덱스 2부터 인덱스 3(4-1)까지 복사된다. 잘라낸 슬라이스는 기본적으로, 내부 배열을 공유한다. 무슨 뜻이냐면,

```go
s3[0] = 999
fmt.Println(s1[2]) // 999 출력

s3 = append(s3, -1) 
// s1 = { 1, 2, 999, 4, -1, 5 }
// s3 = { 999, 4, -1 }
```

그런데, 용량을 정해주면, 용량 초과시 새로운 내부 배열을 만들어 할당한다. 무슨 말이냐면,

```go
s4 := s1[2:4:4] // { 999, 4 } 
s4 = append(s4, -5)
// s1 = { 1, 2, 999, 4, -1, 5 }
// s4 = { 999, 4, -5 } 내부배열 공유가 끊김.
```

슬라이스는 배열과 달리 함수로 전달되면, 참조로 취급 받는다. 무슨 말이냐면, 쉽게 말해서 주소로 전달한 것과 같은 효과가 난다.

```go
func SetIndex(a []int) {
	a[2] = 6
}

// ...
SetIndex(s4) // s4 = {999, 4, 6}
```

위의 코드에서 `SetIndex`를 호출했을 때, 전달된 슬라이스는 값이 변경이 된다. 


## 맵

맵은 키-값 쌍으로 저장하는 데이터 구조 형태이다. 다음과 같이 만들 수 있다.

```go
m1 := map[string]string{
    "RED":    "#da1337",
    "ORANGE": "#e92a22",
    "GREEN":  "#a3ff47",
}
```

또한, `make` 함수를 이용해서 만들 수 있다.

```go
m2 := make(map[string][string])
```

원소 추가는 다음처럼 할 수 있다.

```go
m2["BLACK"] = "#ffffff"
```

추가할 때 키가 중복되면, 갱신된다. 원소 접근 역시 `[]`로 접근한다. 이 때 2개의 결과를 반환하는데, 맵에 키가 존재하면, (키의 값, true)을 존재하지 않으면 ( , false)를 반환한다. 다음처럼

```go
v, isExist := m2["WHITE"]
fmt.Println(v, isExist)     //  false 반환

v, isExist = m2["BLACK"]
fmt.Println(v, isExist)     // #ffffff true 반환
```

원소 삭제는 `delete` 함수로 할 수 있다.

```go
delete(m2, "BLACK")
```

해당 키가 없으면, 아무 동작도 일어나지 않는다. 맵을 순회하는 것은 다음과 같이 할 수 있다.

```go
for k, v := range m1 {
    fmt.Println(k, v)
}
// 이 3개가 무작위 순서로 출력됨
// RED #da1337
// ORANGE #e92a22
// GREEN #a3ff47
```

**맵에서 중요한 것은, 키-값 쌍이 서로 다른 순서로 반환된다는 점이다.** 테스트할 때 유의하자. 키만 알고 있으면 상수 시간에 접근할 수 있다는 또 다른 장점이 있다. 어차피 슬라이스, 맵은 `Go`로 프로그램을 만들면 무수하게 많이 볼 것이다.