# 6장 AOP (1)

![logo](./../logo.png)

    책장속 먼지털기 스터디 9차, 10차
    스터디 날짜 : 2021.01.11, 2021.01.18
    작성 날짜 : 2021.01.10 - 2021.01.18
    페이지 : 401 - 474


## 개요

스프링의 3대 기술은 다음과 같다.

1. IoC/DI (의존성 주입)
2. PSA (서비스 추상화)
3. AOP (관심사의 분리)

이 중 가장 어렵다는 `Aspect Oriented Programming(이하 AOP)`에 대해서 공부한다. 대표적인 예는 이전 장에서 만들었던 "트랜잭션"이다. 따라서 이전 장의 코드를 최대한 활용한다.


## 트랜잭션 코드의 분리

현재 `UserService` 코드의 문제점은 무엇일까? 

    트랜잭션 경계를 담당하는 코드와 비지니스 로직을 담당하는 코드가 뒤섞여 있다.

다음은 위의 문제점을 나타내는 코드의 본문이다.

UserService.java
```java
@RequiredArgsConstructor
@Getter
public class UserService implements UserLevelUpgradePolicy {
    // ...
    public void upgradeLevels() {
        // 트랜잭션을 만든다.
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());

        try {
            // 비지니스 로직을 처리한다.
            List<User> users = userDao.getAll();

            for (User user : users) {
                if (canUpgradeLevel(user)) {
                    upgradeLevel(user);
                }
            }

            // 트랜잭션을 끝낸다.
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

이를 분리할 수 있을까? 가장 쉬운 방법으론 메서드 추출이 있겠다. 하지만 메소드 레벨에서의 분리일뿐 실제적으로 코드가 분리되지는 않는다. 다행히 우리는 여태까지 깔끔하게 코드를 분리하는 방법을 배워왔다. 이를 적용할 수 있지 않을까?

현재 문제점은 클라이언트(`UserServiceTest`)가 `UserService`를 직접 호출함으로써 강하게 결합되어 있다. 다음과 같이 말이다.

![01](./01.png)

이 상태에서 어떻게 트랜잭션 기능을 밖으로 빼버린다면, 클라이언트는 트랜잭션을 담당하는 코드가 빠진채로, 그 기능을 사용할 수 밖에 없다. 이번에도 인터페이스를 도입해보자.

![02](./02.png)

클라이언트와 서비스 코드가 결합이 약해지면서 조금 더 유연하게 확장이 가능하다. 그러나 이 역시도 `UserServiceImpl`에서 트랜잭션과, 비지니스 로직을 담당하는 코드가 뒤섞여 있음이 자명하다. 그렇다면 이런 구조는 어떨까.

![03](./03.png)

그림으로 보면 분리는 되었지만 어떻게 되어 있을지는 잘 감이 안온다. 결론부터 말하면 다음과 같은 구조가 된다. 

1. 애플리케이션에서 `UserService` 자리에는 `UserServiceTx`를 주입시킨다. 
2. 이 `UserServiceTx`는 `UserService`를 가지며 `UserServiceImpl`을 그 자리에 주입시킨다. 
3. 클라이언트가 `UserService.upgradeLevels`를 호출하면 `UserServiceTx.upgradeLevels`가 호출된다.
4. `UserServiceTx.upgradeLevels`에서는 트랜잭션을 처리하고 그 후 `UserServiceImpl.upgradeLevels`를 호출하여 비지니스 로직을 호출한다.
5. 비지니스 로직이 실행된다.

그렇다! 구조로 보면 클라이언트의 요청을 `UserServiceTx`가 받아 트랜잭션 처리 후 `UserServiceImpl`에 넘겨주는 형식이다. "백문이 불여일타!" 한 번 코드로써 살펴보자. 먼저 `UserService` 인터페이스를 다음과 같이 생성하자.

UserService.java
```java
@Service
public interface UserService {
    void add(User user);
    void upgradeLevels();
}
```

기존 `UserService`코드는 `UserServiceImpl`로 변경하고 트랜잭션 기능을 제거해서 코드를 만들어둔다.

UserServiceImpl.java
```java
@RequiredArgsConstructor
@Getter
public class UserServiceImpl implements UserLevelUpgradePolicy, UserService {
    // ... 
    // TransactionManager 제거
    private final MailSender mailSender;
    private final UserDao userDao;

    // ...

    public void upgradeLevels() {
        List<User> users = userDao.getAll();

        for (User user : users) {
            if (canUpgradeLevel(user)) {
                upgradeLevel(user);
            }
        }
    }

    // ...
}
```

이제 트랜잭션을 담당하는 `UserServiceTx`를 만든다.

UserServiceTx.java
```java
@Service
@RequiredArgsConstructor
public class UserServiceTx implements UserService{
    private final UserService userService;
    private final PlatformTransactionManager transactionManager;
    

    @Override
    public void add(User user) {
        userService.add(user);
    }

    @Override
    public void upgradeLevels() {
        // 트랜잭션 경계 설정
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            // 비지니스로직 userService에 위임
            userService.upgradeLevels();

            // 트랜잭션 경계 해제
            transactionManager.commit(status);
        } catch (RuntimeException e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

앞서 말했듯, `UserServiceTx.upgradeLevels`가 호출되면, 트랜잭션을 만들고 실제 비지니스로직은 내부의 `UserService.upgradeLevels`를 호출하여 그 책임을 위임한다. 이제 이를 우리의 의도대로 작동할 수 있게 DI 설정을 한다.

`BeanFactory`는 다음과 같다. (TestBeanFactory도 마찬가지.)

BeanFactory.java
```java
@Configuration
public class BeanFactory {
    // ...

    // Application 전체적으로 주입되는 UserService는 UserServiceTx
    @Bean
    public UserService userService() {
            UserServiceTx userServiceTx = new UserServiceTx(userServiceImpl(), transactionManager());
            return userServiceTx;
    }

    // 이는 UserServiceTx에 넣어주기 위한 비지니스를 가진 UserServiceImpl
    @Bean
    public UserServiceImpl userServiceImpl(){
        UserServiceImpl userServiceImpl = new UserServiceImpl(mailSender(), userDao());
        return userServiceImpl;
    }

    // ...
}
```

이제 실제 클라이언트인 `UserServiceTest`가 동작할 수 있도록 코드를 변경한다. 먼저 목 객체인 `TestUserService`를 다음과 같이 바꾼다.

TestUserService.java
```java
public class TestUserService extends UserServiceImpl {
    private String id;

    public TestUserService(String id, MailSender mailSender, UserDao userDao) {
        super(mailSender, userDao);
        this.id = id;
    }

    public void upgradeLevel(User user) {
        if (user.getId().equals(this.id)) {
            throw new TestUserServiceException();
        }

        super.upgradeLevel(user);
    }
}
```

그 후 이를 참조하는 `UserServiceTest.test_cancel_when_exception`를 다음과 같이 바꾼다.

UserServiceTest.java
```java
@SpringBootTest
@DirtiesContext
@Import(TestBeanFactory.class)
class UserServiceTest {
    // ...
    @Test
    @DisplayName("예외 발생 시 작업 취소 여부 테스트")
    public void test_cancel_when_exception() {
        UserService mock = new TestUserService(users.get(3).getId(), testMailSender, testUserDao);
        UserService userServiceTx = new UserServiceTx(mock, testTransactionManager);

        assertThrows(TestUserServiceException.class, () -> {
            userServiceTx.upgradeLevels();
        });

        checkLevel(users.get(1), false);
    }
}
```

이제 테스트를 돌려보면 정상적으로 동작한다. 후! 우리는 깔끔하게 트랜재션을 담당하는 코드와 비지니스 로직을 담당하는 코드를 분리해내었다.


## 고립된 단위 테스트



## 다이나믹 프록시와 팩토리 빈

## 스프링의 프록시 팩토리 빈